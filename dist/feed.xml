<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[oyyd]]></title>
        <description><![CDATA[oyyd]]></description>
        <link>https://blog.oyyd.net</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Mon, 01 Feb 2016 02:50:05 GMT</lastBuildDate>
        <atom:link href="https://blog.oyyd.netdist/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[使用webpack分割代码的思路]]></title>
            <description><![CDATA[<h1 id="-webpack-">使用webpack分割代码的思路</h1>
<p>2016年01月18日</p>
<p><strong>前言：</strong></p>
<p>可能你跟我一样最开始只是把webpack作为打包的工具，把所有的东西都打包进一个bundle.js文件供我们的应用使用。这种做法不仅简单、利于缓存，更重要的它可以使得我们的JavaScript代码更像是其他的编程语言那样运作，而不用为模块和加载的问题操心太多。但随着代码的不断增长，需要加载的代码会不断增加，并且当我们期望某些页面在移动设备上（app或浏览器）运行时，非wifi的网络环境会使得资源加载时间显得更加不可接受。</p>
<p>好在webpack是个非常强大且扩展性极强的工具，它提供了一些强大的特性来帮助我们解决这一问题。</p>
<h2 id="-">基本原则</h2>
<p>事实上把所有的js文件打包成一个文件是一种极端做法，而按需加载每一个JavaScript文件则是另一种极端做法。这两种做法并没有绝对的优劣，这里我们需要做的事情是在这两个极端之间找到一个相对可以接受的做法。</p>
<p>如果你希望了解得更多的话，可以参考链接中的这篇文章。这篇文章很好地讲述了汗学院面对这一困境的思路：
<a href="http://jamie-wong.com/2014/11/29/the-js-packaging-problem/">The JavaScript Packaging Problem</a></p>
<p>而从缓存、压缩比、请求次数等角度来看，我认为打包的方式是整体优于按需加载的，即“多加载代码”总是整体优于“按需加载代码”。这也是下文做法的依据。</p>
<h2 id="-webpack-">在webpack上我们可以利用的工具</h2>
<p>webpack主要支持两种代码分割方式，一是在应用的代码中设置split points，另一种则是在是在webpack的配置文件中设置代码块。</p>
<h3 id="split-points">split points</h3>
<p>split points会告知webpack代码的分割位置，webpack依次设置代码块(chunk)，并在运行环境中由webpack自动加载代码块：</p>
<pre><code class="lang-js">// 这样的模块会被webpack打包在同一个代码块中，
// 所以我们总是能保证代码已经存在
var _ = require(&#39;lodash&#39;)

// 利用ensure和require来动态加载代码
require.ensure([], function(require) {
  let contacts = require(&#39;./contacts&#39;)
})
</code></pre>
<p>实际上<code>require.ensure</code>这种方式有些像requirejs或其他浏览器上的模块加载库。webpack可以根据split points来将多个文件自动打包成一个代码块（chunk），并在运行时（比如浏览器上）自动加载依赖的代码块。因为是以代码块为单位，而不像其他库一样是以单个JavaScript文件为单位，所以相比于传统的模块相关的库来说，webpack可以帮我们做很多优化。</p>
<p>但值得注意的是，<code>require.ensure</code>并不是真正的动态加载，虽然同样是在运行中加载依赖，但webpack会加载所有的依赖<label for="20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="20" class="margin-toggle"/><span class="sidenote">也有特别的情况，比如在<code>if</code>语句中，如果条件为<code>false</code>，则代码体中的<code>require</code>就不会被执行</span> ，比如在下面的代码中：</p>
<pre><code class="lang-js">require.ensure([], function(require) {
  var shouldLoad = false;
  if (shouldLoad) {
    // 虽然这块代码不会被真正执行，但webpack还是会事先加载这一模块
    let contacts = require(&#39;./contacts&#39;)
  }
})
</code></pre>
<p>虽然这<code>if</code>中的代码不会被真正执行，但webpack还是会事先加载这一模块。</p>
<p>我个人不喜欢这种做法，因为相比于后面在配置中进行的代码分割的方式来说，它实际上在代码中引入了另一种机制来加载模块，代码及加载状态会变得更加复杂。但这种做法把代码的分割加载工作都交给了webpack，充分利用它能省下不少工作，所以充分利用这一特性也是一种选择。</p>
<h3 id="-">通过配置文件分割代码</h3>
<p>另一种方式是在webpack的config文件中配置代码块。单纯配置入口文件的话，webpack会将入口文件所涉及的所有文件都打包到一个文件里面。但这也意味着两个入口文件所生成的代码块之间会有很多重复的部分，并且完全不能利用浏览器的缓存机制。比如你的两个入口文件都用了react，那打包出来的两份文件都会有react，没办法交叉利用。</p>
<p>为了解决这一问题，webpack提供了插件<code>CommonsChunkPlugin</code>来帮助我们自动抽取出代码块中相同的部分：</p>
<pre><code class="lang-js">var path = require(&quot;path&quot;);
var CommonsChunkPlugin = require(&quot;../../lib/optimize/CommonsChunkPlugin&quot;);
module.exports = {
    entry: {
        pageA: &quot;./pageA&quot;,
        pageB: &quot;./pageB&quot;,
        pageC: &quot;./pageC&quot;,
        adminPageA: &quot;./adminPageA&quot;,
        adminPageB: &quot;./adminPageB&quot;,
        adminPageC: &quot;./adminPageC&quot;,
    },
    output: {
        path: path.join(__dirname, &quot;js&quot;),
        filename: &quot;[name].js&quot;
    },
    plugins: [
        //将adminPageA和adminPageB中相同的依赖打包到admin-commons.js文件中
        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;adminPageA&quot;, &quot;adminPageB&quot;]),
        //将pageA、pageA和admin-commons.js中相同的、并且至少被两个chunk使用的依赖打包到commons.js文件中
        //注意这里显示出CommonsChunkPlugin生成的chunk也可作为参数传入
        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;pageA&quot;, &quot;pageA&quot;, &quot;admin-commons.js&quot;], 2),
        //将pageC和adminPageC中相同的依赖打包到c-commons.js文件中
        new CommonsChunkPlugin(&quot;c-commons.js&quot;, [&quot;pageC&quot;, &quot;adminPageC&quot;]),
    ]
}
</code></pre>
<p>然后我们只要在HTML文件中依次引入代码块即可：</p>
<pre><code class="lang-html">&lt;!--pageA.html--&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;js/commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/pageA.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!--adminPageA.html--&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;js/commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/admin-commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/adminPageA.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样，<code>commons.js</code>和<code>admin-commons.js</code>就能够有效地被浏览器缓存了。</p>
<p>特别值得注意的是，<code>CommonsChunkPlugin</code>甚至提供了<code>minChunks</code>和<code>minSize</code>这两个配置来筛选文件，从而调节入口文件（entry）所打包成的文件和通用代码块（commons chunk）之间的大小配比。<code>minChunks</code>和<code>minSize</code>越小，则commons chunk文件则越大，代码被缓存的几率越大，加载的冗余代码也更多；反之commons chunck文件则越小，代码被缓存的几率越小，但加载的冗余代码也更少。</p>
<p>通过编写入口文件我们可以将所有可能被用到的文件打包成一个文件，而通过利用<code>CommonsChunkPlugin</code>，我们可以有效地缓存不同入口文件之间重叠的代码，特别是对非单页应用而言，这点非常重要。这种方式分割的代码不会像split points那样会自动加载，我们需要按照依赖依次引入分割而成的文件。</p>
<h2 id="-">简单的代码分割思路</h2>
<p>首先把所有页面100%会被使用的文件分割出来，即打包成vendor文件。这类文件主要是外部依赖，比如：React、jQuery这样的framework，或是momentjs等经常会用到的代码库。</p>
<p>然后再为需要严格控制js文件大小的页面编写独立的入口文件，比如运行在移动设备上的活动页面。独立的入口文件会保证打包出来的文件没有（太多）冗余。</p>
<p>对于其他没有那么严格的要求的页面来说，我们可以从整体按照某一套规则来分割代码。比如前面链接中的汗学院把代码分割成了：<code>core-package.js</code>，<code>content-package.js</code>，<code>homepage-package.js</code>。</p>
<p>问题是通过配置打包成的文件需要我们手动管理依赖，即按照依赖关系在页面中依次引入script标签，这种做法在依赖十分复杂的情况下是不可接受的。那这时候通过<code>require.ensure</code>来帮助我们管理依赖或许是个不错的主意。</p>
]]></description>
            <link>https://blog.oyyd.net/post/how_to_split_your_code_in_webpack</link>
            <guid isPermaLink="false">89b1ca0a33a279b425951b43ee4081db</guid>
            <pubDate>Sun, 17 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— nunjucks]]></title>
            <description><![CDATA[<h1 id="-javascript-nunjucks">探究JavaScript上的编译器 —— nunjucks</h1>
<p>2016年01月12日</p>
<h2 id="-">写在前面的实践结果</h2>
<p>在前面<a href="https://blog.oyyd.net/post/javascript_compiler_marked">marked的学习过程</a>中，我简单地hack了marked来绑定了chartjs。但对于<a href="https://github.com/mozilla/nunjucks">nunjucks</a>，我没有想到比较好的实践方式。所以这次我将帮助修复nunjucks上的一些bug来作为本次实践。</p>
<p>到目前为止，已尝试修复的问题有：<a href="https://github.com/mozilla/nunjucks/pull/634">#571</a>, <a href="https://github.com/mozilla/nunjucks/pull/632">#332</a>, <a href="https://github.com/mozilla/nunjucks/pull/631">#595</a>, <a href="https://github.com/mozilla/nunjucks/pull/628">#612</a>, <a href="https://github.com/mozilla/nunjucks/pull/339">#317</a></p>
<h2 id="nunjucks-">nunjucks的代码结构</h2>
<p>nunjucks的整体代码结构如下：</p>
<p><img src="/static/posts/javascript-compiler/nunjucks.png" alt="nunjucks"></p>
<p>接下来再让我们看看每一部分的作用。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer中最主要的类被命名为Tokenizer，这听起来与Scanner异曲同工。</p>
<p>模板引擎的模板代码可以很容易地被分为成两种，一种将直接用于输出（即Lexer生成的TOKEN_DATA），另一种则可能有复杂的逻辑于其中。nunjucks在Lexer中有一个in_code属性用于储存当前的解析状态，并依次进行两套不同的解析规则。</p>
<p>下面展示了一段模板所生成的tokens：</p>
<pre><code class="lang-js">nunjucks.renderString(&#39;&lt;h1&gt; Hello, {{ me }}! &lt;/h1&gt;&#39;, { me: &#39;oyyd&#39; })

// 生成的tokens:
// { type: &#39;data&#39;, value: &#39;&lt;h1&gt; Hello, &#39;, lineno: 0, colno: 0 }
// { type: &#39;variable-start&#39;, value: &#39;{{&#39;, lineno: 0, colno: 12 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 12 }
// { type: &#39;symbol&#39;, value: &#39;me&#39;, lineno: 0, colno: 13 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 15 }
// { type: &#39;variable-end&#39;, value: &#39;}}&#39;, lineno: 0, colno: 16 }
// { type: &#39;data&#39;, value: &#39;! &lt;/h1&gt;&#39;, lineno: 0, colno: 16 }
</code></pre>
<p>Tokenizer只是将源码转换成tokens供其它代码使用。Tokenizer碰到什么字符就会试着把它转换成token，它不会参与任何高层次的逻辑，比如不会检查“{{”和“}}”是否配对。这一检查实际上是在Parser中进行的。</p>
<h3 id="parser">Parser</h3>
<p>Parser实际上是对tokens进行处理，以保证代码的语法规则合法，并据此生成由node组成的AST。</p>
<p>比如当出现“{{”时（TOKEN_BLOCK_START），Parser就会尝试在剩余的tokens中寻找“}}”（TOKEN_BLOCK_END）。如果没有找到，则Parser会认为代码不符合语法规则，从而抛出异常。</p>
<p>这里非常值得一提的是AST的生成方式。我们先来看看nunjucks尝试解析<code>or</code>的方法，注意代码中的注释：</p>
<pre><code class="lang-js">// ...
parseOr: function() {
    var node = this.parseAnd(); // 注意这里
    while(this.skipSymbol(&#39;or&#39;)) {
        var node2 = this.parseAnd(); // 注意这里
        node = new nodes.Or(node.lineno,
                            node.colno,
                            node,
                            node2);
    }
    return node;
},
// ...
</code></pre>
<p>我们可以看出在解析<code>or</code>之前，Parser首先会尝试解析<code>and</code>。而尝试解析<code>and</code>的代码如下：</p>
<pre><code class="lang-js">// ...
parseAnd: function() {
    var node = this.parseNot(); // 注意这里
    while(this.skipSymbol(&#39;and&#39;)) {
        var node2 = this.parseNot(); // 注意这里
        node = new nodes.And(node.lineno,
                             node.colno,
                             node,
                             node2);
    }
    return node;
},
// ...
</code></pre>
<p>和而如果你去看Parser尝试解析<code>not</code>的代码则会发现<code>parseNot</code>又会尝试先去解析其他语法。仔细思考一下<code>or</code>、<code>and</code>和<code>not</code>的关系你会发现他们是按照自己在语法中的优先级先后进行的，即Parser会优先尝试寻找高优先级的语法标识。并且对于AST来说，通常高优先级的语法只会是低优先级语法的子孙节点，比如对于：</p>
<pre><code class="lang-js">a and b or c
</code></pre>
<p>它的AST中<code>and</code>会是<code>or</code>的左子节点，即便调换他们的位置:</p>
<pre><code class="lang-js">a or b and c
</code></pre>
<p><code>and</code>仍旧是<code>or</code>的子节点，只不过变成了右子节点。</p>
<p>通过这样的做法，Parser将所有的tokens整合成了一棵树，而这棵树的根节点是全局只应有一个的<code>Root</code>。</p>
<p>如果你有兴趣了解得更仔细的话，可以看看下面的这个由Parser生成的AST。下面的模板代码：</p>
<pre><code class="lang-html">&lt;p&gt;
  Hi, I&#39;m
  {%if name and isNameValid or forceShowName%}
    &lt;span&gt;{{name}}&lt;/span&gt;
  {%endif%}
&lt;/p&gt;
</code></pre>
<p>生成的AST如下（注释为节点类型）：</p>
<pre><code class="lang-js">{ parent: undefined, // Root
  lineno: 0,
  colno: 0,
  children:
   [ { parent: undefined, // Output
       lineno: 0,
       colno: 0,
       children:
        [ { lineno: 0, colno: 0, value: &#39;&lt;p&gt;\n  Hi, I\&#39;m\n  &#39; }, // TemplateData
          [length]: 1 ] },
     { lineno: 2, // If
       colno: 2,
       cond:
        { lineno: 2, // Or
          colno: 5,
          left:
           { lineno: 2, // and
             colno: 5,
             left: { lineno: 2, colno: 5, value: &#39;name&#39; }, // Symbol
             right: { lineno: 2, colno: 14, value: &#39;isNameValid&#39; } }, // Symbol
          right: { lineno: 2, colno: 29, value: &#39;forceShowName&#39; } }, // Symbol
       body:
        { parent: undefined, // NodeList
          lineno: 0,
          colno: 0,
          children:
           [ { parent: undefined, // Output
               lineno: 2,
               colno: 42,
               children: [ { lineno: 2, colno: 42, value: &#39;\n    &lt;span&gt;&#39; }, [length]: 1 ] }, // TemplateData
             { parent: undefined, // Output
               lineno: 3,
               colno: 10,
               children: [ { lineno: 3, colno: 10, value: &#39;name&#39; }, [length]: 1] }, // Symbol
             { parent: undefined, // Output
               lineno: 3,
               colno: 14,
               children: [ { lineno: 3, colno: 14, value: &#39;&lt;/span&gt;\n  &#39; }, [length]: 1 ] }, // TemplateData
             [length]: 3 ] },
       else_: null },
     { parent: undefined, // Output
       lineno: 4,
       colno: 7,
       children: [ { lineno: 4, colno: 7, value: &#39;\n&lt;/p&gt;&#39; }, [length]: 1 ] }, // TemplateData
     [length]: 3 ] }
</code></pre>
<h3 id="compiler">Compiler</h3>
<p>Compiler使用AST生成中间代码。nunjucks运行在node上，所以nunjucks生成的中间代码自然就是JavaScript代码，这也意味着nunjucks可以运行在浏览器上。</p>
<p>AST中的nodes会被用来生成JavaScript代码片段，上文Parser中的那段模板代码生成的中间代码如下:</p>
<pre><code class="lang-js">function root(env, context, frame, runtime, cb) {
  var lineno = null;
  var colno = null;
  var output = &quot;&quot;;
  try {
    var parentTemplate = null;
    output += &quot;&lt;p&gt;\n  Hi, I&#39;m\n  &quot;;
    if (runtime.contextOrFrameLookup(context, frame, &quot;forceShowName&quot;) || runtime.contextOrFrameLookup(context, frame, &quot;name&quot;) &amp;&amp; runtime.contextOrFrameLookup(context, frame, &quot;isNameValid&quot;)) {
      output += &quot;\n    &lt;span&gt;&quot;;
      output += runtime.suppressValue(runtime.contextOrFrameLookup(context, frame, &quot;name&quot;), env.opts.autoescape);
      output += &quot;&lt;/span&gt;\n  &quot;;;
    }
    output += &quot;\n&lt;/p&gt;&quot;;
    if (parentTemplate) {
      parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);
    } else {
      cb(null, output);
    };
  } catch (e) {
    cb(runtime.handleError(e, lineno, colno));
  }
}
return {
  root: root
};
</code></pre>
<p>在Environment中，中间代码被作为函数体用来生成一个函数：</p>
<pre><code class="lang-js">var props = new Function(
  codeString // 中间代码
);
</code></pre>
<p>并且中间代码生成的函数将是个纯函数，传入同样的参数给它会得到同样的结果，这也就意味着在nunjucks中，编译的结果（到Compiler这一步的结果）可以被缓存起来，供以后直接使用，而不需要每次都进行编译。保存完编译结果以后以后，我们就不再需要模板了，而可以直接使用编译结果以提高性能并缩小浏览器上nunjucks文件的大小（即使用nunjucks-slim.js<label for="21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="21" class="margin-toggle"/><span class="sidenote">现在这个时间点nunjucks.min.js文件大小为69KB,nunjucks-slim.min.js大小为24KB</span> ）。这就是nunjucks中的precompile特性，也是提高模板引擎性能的关键。</p>
<h3 id="context-environment-template">Context &amp;&amp; Environment &amp;&amp; Template</h3>
<p>到目前为止，有了中间代码以后，我们只要传入参数就可以生成目标代码(HTML)了。而从外部传入的参数分为两种，上下文环境（渲染过程中直接使用到的变量等）储存在Context中，而配置等参数将被储存在Environment中。而Template最主要的目的则是组合使用Environment，其作用可以简单地理解为：</p>
<pre><code class="lang-js">return root( // root为中间代码生成的函数
  ctx, // 上下文环境
  env // 配置等
);
</code></pre>
<p>nunjucks提供给开发者的api和配置的相关代码大多应该可以在这里找到。</p>
<p>至此主要的编译过程也就结束了。</p>
<h2 id="-">其他</h2>
<p>事实上nunjucks还有不少高级特性值得探讨，比如async（transformer.js），它会改变parser的结构。这些内容就留待以后再探讨吧。</p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_nunjucks</link>
            <guid isPermaLink="false">a2c9ce9544918e833018f3c6ee9f6ab9</guid>
            <pubDate>Mon, 11 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— marked]]></title>
            <description><![CDATA[<h1 id="-javascript-marked">探究JavaScript上的编译器 —— marked</h1>
<p><strong>前言：</strong></p>
<p>如果你也用google去搜过编译相关的话题的话，会发现很难找到适合入门的内容。但与之相对的是，很多的库和特性的实现都离不开编译这一流程，我们去看一些开源的JavaScript代码时也经常会看到Lexer，Parser，Compiler，AST等东西。如果没有相关知识，那看这些代码时经常会一头雾水。</p>
<p>实际上在学习这部分内容时，可能阅读书籍(<a href="http://www.amazon.com/dp/0321486811/?tag=stackoverfl08-20">编译原理</a>)是最合适的。因为编译的原理基本相近，也没有随时间推移而发生大的改变，经典的书籍依旧非常适用，但这里将尝试通过一些开源项目的代码来学习编译。虽然这种学习方式可能不够详尽，容易遗漏内容，但它也更有利于我们学习到开发实践中常用的编译（它们的代码结构通常会更加简单），以及了解不同环境下的编译过程的设计。</p>
<p>但这个话题本身涉及的范围较广，内容较深，所以对这些内容的学习将通三个项目的源码进行，它们分别是：<a href="https://github.com/chjj/marked">marked</a> —— 它将markdown文本转换成可供浏览器使用的HTML标签, <a href="https://github.com/mozilla/nunjucks/">nunjucks</a> —— 模板引擎和<a href="http://zaach.github.io/jison/">Jison</a> —— 一个通用的parser生成器，三部分进行。</p>
<p>那这次让我们从marked开始。</p>
<h2 id="-">基础理论：一个编译器的结构</h2>
<p>首先还是让我们通过来粗略了解一下编译器的通用结构（摘自编译原理）：</p>
<ol>
<li><p>Lexical Analysis/Scanning（词法分析），在marked中由Lexer实现。</p>
</li>
<li><p>Syntax Analysis/Parsing（语法分析），在marked中由Parser实现。</p>
</li>
<li><p>Semantic Analysis（语义分析），代码优化，在marked中没有实现。</p>
</li>
<li><p>代码生成，在marked中由Parser和Renderer实现。</p>
</li>
</ol>
<h2 id="marked-">marked中的代码结构</h2>
<p>marked的目的是根据输入的markdown文本来输出可供浏览器解析的HTML内容，藉由：</p>
<pre><code class="lang-markdown"># 探究JavaScript上的编译器 —— marked

编译这个话题在JavaScript上很少出现...
</code></pre>
<p>生成类似这样的代码：</p>
<pre><code class="lang-html">&lt;h1&gt;探究JavaScript上的编译器 —— marked&lt;/h1&gt;
&lt;p&gt;
  编译这个话题在JavaScript上很少出现...
&lt;/p&gt;
</code></pre>
<p>编译目标的不同会直接使得我们代码结构大相径庭。所以对任何编译相关的代码，时刻明确我们的设计的目的可以很好地帮助我们理解代码。</p>
<p>marked由四部分组成，分别是: Lexer、InlineLexer、Parser、Renderer。</p>
<p><img src="/static/posts/javascript-compiler/marked_composition.png" alt="marked-composition"></p>
<p>其中Lexer会处理最原始的文本，它将文本处理、抽象，提供tokens供Parser使用；Renderer提供一组api供Parser和InlineLexer调用，以生成HTML；而Parser将对Lexer提供的tokens进行进一步处理，并据此调用Renderer中的api生成最终的HTML字符串。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer用来将源码转换成tokens供Parser使用，其表现如下：</p>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# title&#39;);

// tokens:  
// [ { type: &#39;heading&#39;, depth: 1, text: &#39;title&#39; } ]
</code></pre>
<p>Lexer生成的tokens事实上只是对源码的抽象和描述。通常tokens都会有一个属性来描述其“类型”（上面生成的tokens中的“type”属性），并有可能有一个或多个“值”属性来描述具体信息（上面tokens中的“title”和“title”属性）。</p>
<h3 id="inlinelexer">InlineLexer</h3>
<p>marked中还有InlineLexer，从名称上看我们可以猜测它的整体作用和Lexer相近。但InlineLexer是有两点不同：一是InlineLexer只用于处理诸如：<code>__strong__</code>、<code>~~line-through~~</code>这样的内联文本；二是InlineLexer不返回tokens给Parser使用，它会直接利用Renderer将源码转换成HTML内容。</p>
<pre><code class="lang-js">const output = marked.InlineLexer.output(&#39;__strong content__&#39;, {}, {});
// output: &#39;&lt;strong&gt;strong content&lt;/strong&gt;&#39;
</code></pre>
<p>所以Parser在处理内联文本时，是直接使用InlineLexer生成结果，而不是像Lexer一样依据tokens用Renderers生成HTML。</p>
<h3 id="renderer">Renderer</h3>
<p>在Parser之前，我们先来看看Renderer的表现。我们可以直接使用Renderer生成HTML:</p>
<pre><code class="lang-js">const options = {
  headerPrefix: &#39;header-id&#39;,
};
const renderer = new marked.Renderer(options);
const output = renderer.heading(&#39;hello world&#39;, 2, &#39;&#39;);

// output: &#39;&lt;h2 id=&quot;header-id&quot;&gt;hello world&lt;/h2&gt;&#39;
</code></pre>
<p>我们可以看到在marked中，Renderer上的方法生成的内容就是我们所期望的HTML内容了。</p>
<h3 id="parser">Parser</h3>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# hello world&#39;);
const output = marked.Parser.parse(tokens);
// output: &lt;h1 id=&quot;hello-world&quot;&gt;hello world&lt;/h1&gt;
</code></pre>
<p>因为markdown的语法规则不像编程语言一样复杂，所以marked中的Parser相对简单，基本上就是按顺序将tokens转换成转换成HTML内容。</p>
<h2 id="-marked">实践：扩展marked</h2>
<p>为了验证对marked的理解是否正确，我试着fork并修改了marked的代码（<a href="https://github.com/oyyd/marked-chartjs-binding">github地址</a>），绑定了chartjs，令我们可以在markdown中调用渲染图表。</p>
<p>你可以在这篇关于<a href="https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages">Universal React</a>的文章底部的benchmark部分看到柱状图。</p>
<p>在修改中，我加入了如下的语法：</p>
<pre><code class="lang-md">graph.chartName
// JSON data here which will be used by
endgraph
</code></pre>
<p>其中chartName将被用作chartjs的图表名，如：graph.Bar将使用chartjs中的Bar表。其对应的token形如：</p>
<pre><code class="lang-js">{
  type: &#39;graph&#39;,
  name: &#39;chartName&#39;, // chartn
  data: &#39;...&#39; // expecting JSON string containing `data` and `options` as the parameters of Chart
}
</code></pre>
<p>而在<code>graph.chartName</code>和<code>endgraph</code>之间的内容将作为图表的参数。修改过后的marked最终渲染出如下的内容：</p>
<pre><code class="lang-html">&lt;script type=&quot;text/chartdata&quot; data-chartname=&quot;chartName&quot;
  style=&quot;display:none;&quot;&gt;
// ...json string here
&lt;/script&gt;
</code></pre>
<p>事实上我们只是渲染了一个script标签来保留图表信息，修改过后的marked并不能让我们在浏览器上直接看到图表。这是由于浏览器的限制，涉及到script的内容在处理时会遇到各种问题，所以在我的处理里，我使用<code>renderCharts()</code>方法去文档中搜索这样的标签，从而真正地渲染图表。</p>
<h2 id="-">相关链接</h2>
<p><a href="http://programmers.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler">How to write a very basic compiler</a></p>
<p><a href="http://stackoverflow.com/questions/2842809/lexers-vs-parsers">lexers vs parsers</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_marked</link>
            <guid isPermaLink="false">d1d5084ec80418fd578b0a8d67e82bcc</guid>
            <pubDate>Sun, 03 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究用ES6 template strings替代前后端模板引擎]]></title>
            <description><![CDATA[<h1 id="-es6-template-strings-">探究用ES6 template strings替代前后端模板引擎</h1>
<p><strong>前言：</strong></p>
<p>JavaScript上有很多的模板引擎，不管是用于前端的、后端的、两者兼顾的，或是特性丰富的，或是在模板中尽可能减少逻辑的，选择十分丰富。如果你也曾在一个或大或小的项目中考虑如何选择模板引擎的话，那你肯定也和我一样犹豫过要怎么选择。</p>
<p>另一方面，在我大量使用React的工作时间中，我越发认可React中jsx的设计$sidenote(<a href="http://blog.vjeux.com/2013/javascript/jsx-e4x-the-good-parts.html">JSX: E4X The Good Parts</a>
)。而当我从React jsx的角度考虑一个好的模板引擎应该具有什么样的特性时，我意识到，对于比较简单的情形，使用ES6中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template strings</a>外加一些约定就已经足矣。你甚至不需要模板引擎就能够很好地处理绝大多数你以前需要用模板引擎来处理的工作。</p>
<p>那么下面就让我们来简单地探讨一下用ES6 template strings替代模板引擎的可行性及其优劣。</p>
<h2 id="-">一个简单的实例</h2>
<p>像是我的这个博客的一部分模板工作是直接利用template strings完成的（剩下的是React renderToString完成的）：</p>
<p>head标签的模板:</p>
<pre><code class="lang-js">// createHead.js
function createHead(ctx) {
  let {title, description} = ctx;

  return (
    `&lt;head&gt;
      &lt;title&gt;${title}&lt;/title&gt;
      &lt;meta name=&quot;description&quot; content=&quot;${description}&quot;/&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
      &lt;link rel=&quot;shortcut icon&quot; href=&quot;/static/favicon.ico&quot; /&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/codemirror.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/theme/monokai-sublime.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
    &lt;/head&gt;`
  );
}

export default createHead;
</code></pre>
<p>使用head标签模板，并引入每个页面的具体内容：</p>
<pre><code class="lang-js">// createPage.js
import createHead from &#39;./createHead&#39;;

function createPage(ctx) {
  let {title, description, content, initialState} = ctx;

  title = title || &#39;oyyd blog&#39;;
  description = description || &#39;这是亚东的博客，你可以在上面看到我的一些想法和实践，欢迎来访。&#39;;
  initialState = initialState || &#39;null&#39;;

  return (
    `&lt;!DOCTYPE html&gt;
    &lt;html&gt;
      ${createHead({title, description})}
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${content}&lt;/div&gt;
        &lt;script&gt;
          window.__INITIAL_STATE__ = JSON.parse(&quot;${initialState}&quot;);
        &lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/codemirror.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/javascript/javascript.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/xml/xml.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          (function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);

          ga(&#39;create&#39;, &#39;UA-70462946-1&#39;, &#39;auto&#39;);
          ga(&#39;send&#39;, &#39;pageview&#39;);
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
}

export default createPage;
</code></pre>
<p>这样，我们就在没有引入模板引擎的情况下，完成了这些简单的工作。</p>
<h2 id="-api-">对比实现其他模板引擎中的一些API与特性</h2>
<p>为了进一步探讨用template strings替代模板引擎的可行性，我们将对比实现其他模板引擎中的一些特性。</p>
<p>这里我们挑选的是<a href="http://mozilla.github.io/nunjucks/templating.html">nunjucks</a>中的一些特性，因其特性相对强大，更容易帮助我们说明template strings的特点及局限性。</p>
<p>另外，如果有些什么是template strings没有，而其他模板引擎做得到的话，你可以考虑用其他javascript的方式来实现，毕竟 <strong>你可以直接使用javascript这一强大的语言环境，通常再写一个函数/模板都能解决你的问题</strong>。并且相比于评价其好坏，你可能更需要去思考一下你是否真的需要这一特性。</p>
<h3 id="-">表达式</h3>
<p>nunjucks:</p>
<pre><code class="lang-html">{{ numItems*2 }}
</code></pre>
<p>template strings本身接受的就是表达式：</p>
<pre><code class="lang-js">`
${ numItems * 2 }
`
</code></pre>
<h3 id="if-else">if else</h3>
<p>nunjucks中的条件语句十分灵活：</p>
<pre><code class="lang-html">{% if hungry %}
  I am hungry
{% elif tired %}
  I am tired
{% else %}
  I am good!
{% endif %}
</code></pre>
<p>因为template strings只接受表达式的值，所以你最多只能用boolean-exp：</p>
<pre><code class="lang-js">`
${ hungry ? (
  I am hungry
) : (
  I am not hungry
) }
`
</code></pre>
<h3 id="for">for</h3>
<p>假设我们有：</p>
<pre><code class="lang-js">var points = [[0, 1, 2], [5, 6, 7], [12, 13, 14]];
</code></pre>
<p>在nunjucks中的：</p>
<pre><code class="lang-html">{% for x, y, z in points %}
  Point: {{ x }}, {{ y }}, {{ z }}
{% endfor %}
</code></pre>
<p>虽然template strings只接受表达式，但还是可以这样完成实现:</p>
<pre><code class="lang-js">`${points.map(({x, y, z}) =&gt; (
  `Point: ${x}, ${y}, ${z}`
)).join(&#39;&#39;)}`
</code></pre>
<h3 id="-asynceach-asyncall">异步操作asyncEach与asyncAll</h3>
<p>nunjucks支持一些异步操作：</p>
<pre><code class="lang-html">&lt;h1&gt;Posts&lt;/h1&gt;
&lt;ul&gt;
{% asyncAll item in items %}
  &lt;li&gt;{{ item.id | lookup }}&lt;/li&gt;
{% endall %}
&lt;/ul&gt;
</code></pre>
<p>我们没办法直接在template strings中做这件事。但如果只是进行简单的异步操作的话，我们可以在外部进行处理，并且这和其他用javascript处理异步操作的情况一致：</p>
<pre><code class="lang-js">function renderPosts(posts) {
  return new Promise((resolve, reject) =&gt; {
    let content = &#39;&#39;;

    // 写些异步操作来修改content
    // ...

    resolve(`
      &lt;h1&gt;Posts&lt;/h1&gt;
      &lt;ul&gt;
        ${content}
      &lt;/ul&gt;
    `);
  });
}
</code></pre>
<p>但如果想要我们的模板整体支持异步的话，我们就需要写一些额外的代码来做这件事。而避免在你的模板中使用异步操作也是个选择。</p>
<h3 id="autoescaping">Autoescaping</h3>
<p>在nunjucks中，当<code>autoescape</code>选项被设置为<code>true</code>时，nunjucks会默认地转义变量的值，以防止可能来自用户的攻击。在使用template strings时，我们不难转义单个变量的值：</p>
<pre><code class="lang-js">var username = &#39;&lt;script&gt;&lt;/script&gt;&#39;;

function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

return `&lt;div&gt;{ escapeHTML(username) }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>而如果我们不想每次都手动调用转义函数，而是想要默认转义所有变量的值的话，我们可以利用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings">Tagged template strings</a>这一特性：</p>
<pre><code class="lang-js">function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${str}` : `${str}${escapeHTML(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`&lt;div&gt;{ uesrname }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>Tagged template strings这一特性很强大，你需要去充分利用它<label for="22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="22" class="margin-toggle"/><span class="sidenote">Tagged templates invite library designers to create powerful domain-specific languages. ——<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/">ES6 In Depth: Template strings</a></span> 。</p>
<h3 id="comments">comments</h3>
<p>在nunjucks中我们可以写注释：</p>
<pre><code class="lang-html">{# Loop through all the users #}
{% for user in users %}...{% endfor %}
</code></pre>
<p>并且模板中的注释在生成的字符串中会被自动截掉。如果我们想在template strings中写注释的话，我们就需要直接写成HTML的注释：</p>
<pre><code class="lang-js">`
&lt;!-- Loop through all the users --&gt;
`
</code></pre>
<p>那么我们能否在模板生成的字符串中自动截取掉这些注释呢？那我们还是要利用tagged template strings：</p>
<pre><code class="lang-js">function trimComments(str) {
  return str.replace(/&lt;!--.*?--&gt;/g, &#39;&#39;);
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${trimComments(str)}` : `${trimComments(str)}${trimComments(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`
  &lt;!-- Loop through all the users --&gt;
`;
</code></pre>
<h3 id="-">动态生成模板</h3>
<p>大部分模板引擎都可以动态生成模板，因为生成模板的过程实际上是在js上进行的一次编译过程，比如在nunjucks中：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;Hello {{ username }}&#39;;
var res = nunjucks.renderString(template, { username: username });
</code></pre>
<p>我们可以通过eval方法来动态生成模板：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;`Hello ${ username }`&#39;;
// 你应该需要更稳健的写法
var res = eval(template);
</code></pre>
<h2 id="-template-strings-">用template strings替代模板引擎的优点和缺点</h2>
<p>到目前位置，我们主要讨论了用template strings来替代模板引擎的可行性，下面我们会讨论这样做的优点和缺点。</p>
<p>模板引擎是<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>，其目的是拼接字符串。没有模板引擎我们当然也可以拼接字符串，只不过这一过程会很痛苦。而template strings本身就是为了解决这一问题而设计的，而tagged template strings又足够帮助我们实现模板引擎的功能<label for="23" class="margin-toggle sidenote-number"></label><input type="checkbox" id="23" class="margin-toggle"/><span class="sidenote">利用tagged template strings开发DSL当然也是可行的，这里的讨论不涉及开发DSL的情况</span> 。</p>
<p>由于各种原因，通常模板引擎在处理很多问题时，通常会有自己的一套方法，比如说在一个模板中引入另一个模板你可能需要用import/require/partials语句，这实际上和JavaScript本身的import解决的是相似的问题。所以在使用template strings时，面对这些情况，我们就可以直接利用JavaScript中的特性来实现，而不需要像那样用一套新的东西来解决相似的问题。</p>
<p>这样很自然地，使用template strings替代模板引擎最主要的优点在于：</p>
<ol>
<li><p>贴近原生JavaScript，学习曲线更低。</p>
</li>
<li><p>你可以充分利用已有的JavaScript代码和特性，任何新的需求都可以通过你熟悉的JavaScript进行拓展。</p>
</li>
<li><p>你的模板部分的内容天然就是Universal JavaScript，你天然地就可以同时在浏览器上和服务器上使用模板相关的代码。</p>
</li>
</ol>
<p>但模板引擎毕竟是专门为处理模板而生的，有些用JavaScript实现比较麻烦的场景，用模板引擎的语法可能可以轻松地解决。实际上这里的讨论更像是在讨论使用DSL的优缺点。但使用template strings的理由在于 <strong>很多模板引擎上的很多特性都和JavaScript（ES6+）本身的特性重合了，我们没必要用一套新东西解决同样的问题</strong>。当然在ES6之前，JavaScript本身也没有模块，更别说考虑直接使用JavaScript中的特性来解决模板上的问题。</p>
<p>而另一个推荐使用template strings的原因在于Universal JavaScript。如果模板本身就是JavaScript代码的话，那么在前后端同时使用一份代码会变得容易得多。</p>
<p>另外不分离模板与代码的这一想主要是受到React的启发。React中的HTML(Virtual DOM, React DOM)部分和JavaScript代码紧密贴合<label for="24" class="margin-toggle sidenote-number"></label><input type="checkbox" id="24" class="margin-toggle"/><span class="sidenote">这里主要是对比Angular和Polymer等框架，即主要由JavaScript代码控制HTML内容，而不是以HTML为主，也不是HTML和JavaScript平分秋色</span> 的想法，至少从实践角度上来说是很有效的，它使得代码十分容易维护。那么对于模板来说，不去刻意分离模板代码与普通的代码、模板代码既是JavaScript代码或许是个好的思路。</p>
<h2 id="-">生产环境上的应用</h2>
<p>在生产环境上单单使用template strings没办法解决我们的所有需求，而截止至本文时点我也没有看见过任何类似的实现。所以如果你觉得这是个好主意，你需要充分利用tagged template strings这一特性来组织起模板层。万幸的是这一过程不需要涉及编译，所以这会远比重新写一个模板引擎要简单得多。之后我也会尝试写一个帮助实现这一目的的库。</p>
<h2 id="-">其他相关链接</h2>
<p><a href="http://www.2ality.com/2015/01/template-strings-html.html">HTML templating with ES6 template strings</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/best_template_engine_in_node_js</link>
            <guid isPermaLink="false">e376e1b601f9fe30966dd8f5ca201e23</guid>
            <pubDate>Tue, 15 Dec 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究Webpack中的HMR(hot module replacement)]]></title>
            <description><![CDATA[<h1 id="-webpack-hmr-hot-module-replacement-">探究Webpack中的HMR(hot module replacement)</h1>
<p>2015年12月04日</p>
<p>什么是HMR？HMR能做什么？我们可以看看react-transform的演示：
<img src="/static/posts/webpack-hmr/react-transform-example.gif" alt="react-transform-example"></p>
<p>react-transform的实现是基于webpack-dev-server之上的，这里我将从webpack-dev-server和React两方面简单总结HMR的实现原理。</p>
<p>（<a href="https://github.com/oyyd/oyyd-blog/tree/master/research/react-hot-loader">从这里查看下文中的部分代码</a>）</p>
<h2 id="-webpack-dev-server-">从webpack-dev-server开始</h2>
<p>webpack不仅能够起到打包的作用，它还“附带了”一个专门用于开发的、由express构建的迷你服务器，即webpack-dev-server。webpack-dev-server的基本作用是处理我们的打包任务，并且它还会作为一个静态文件服务器提供我们最新打包成的静态文件供本地开发使用。webpack-dev-server与我们平时开发用的静态文件服务器的不同之处在于，它知道新的文件在何时被打包了出来，以及究竟是哪个文件发生了改变。</p>
<p>在“webpack-dev-server知道何时新文件会被打包出来的”这个基础之上，webpack-dev-server可以和浏览器之间建立一个web socket进行通信，一旦新文件被打包出来，webpack-dev-server就告诉浏览器这个消息，这时浏览器就可以自动刷新页面<label for="25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="25" class="margin-toggle"/><span class="sidenote">或是刷新iframe</span> ，而不用等到开发者手动刷新。</p>
<p><img src="/static/posts/webpack-hmr/hot-reload.gif" alt="complete-version"></p>
<p>对的，到这里webpack实际上已经实现了<a href="http://livereload.com/">livereload</a>的功能。</p>
<h2 id="-hmr-api">使用HMR的相关api</h2>
<p>webpack知道是哪个模块发生了改变，并且还提供了api帮助我们更新应用的状态。在这基础之上，只要我们知道要怎么用更新后的模块来更新我们的应用，我们就不需要刷新页面来重新加载整个应用了。</p>
<p>比如说我们需要使用一个模块A，这个模块A是个React Component，用来在页面上渲染<code>hello world</code>。对于这个简单的React Component来说，我们只需要在它更新以后重新渲染就能够保持应用的状态，而不需要其他工作。所以我们可以像下面这样做：</p>
<p>我们的SayHello.js文件：</p>
<pre><code class="lang-js">// SayHello.js
import React from &#39;react&#39;;

const color = &#39;black&#39;;

class SayHello extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div style={{color: color}}&gt;Hello, {this.props.name}!&lt;/div&gt;
    );
  }
}

export default SayHello;
</code></pre>
<p>我们的sayHelloEntry.js，</p>
<pre><code class="lang-js">// sayHelloEntry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import SayHello from &#39;./SayHello&#39;;

const name = &#39;world&#39;;

function renderComponent(RootComponent) {
  ReactDOM.render(
    &lt;RootComponent name={name}/&gt;,
    document.getElementById(&#39;main&#39;)
  );
}

// 通过module.hot获取webpack提供的一系列的api
if (module.hot) {
  module.hot.accept(); // 接受模块更新的事件，同时阻止这个事件继续冒泡
  renderComponent(SayHello); // 进行渲染
} else {
  // 非HMR状态下的代码
  renderComponent(SayHello);
}
</code></pre>
<p>在浏览器上加载这个页面后，我们就可以尝试修改sayHelloEntry.js模块中的<code>name</code>的值或是SayHello.js模块中的内容来查看结果：</p>
<p><img src="/static/posts/webpack-hmr/simple-version.gif" alt="complete-version"></p>
<p>虽然这个例子非常简单，但它也足以说明在webpack中的HMR的基本原理了。而你也应该很快注意到了，虽然在开发过程中，所有模块都有可能发生改变，但我们并不需要为每个模块写HMR代码。</p>
<p>那么当没有HMR相关代码的模块发生改变时，我们的应用到底是怎么运作的呢？这就是webpack HMR中的消息<label for="26" class="margin-toggle sidenote-number"></label><input type="checkbox" id="26" class="margin-toggle"/><span class="sidenote">称为消息可能并不合适，但下文就这么用吧</span> 冒泡（bubble up）机制。</p>
<p><img src="/static/posts/webpack-hmr/bubble-up.png" alt="bubble-up"></p>
<p>当一个模块C发生改变，而模块内又没有HMR代码来处理这一消息时，那这一消息就会被传递到依赖模块C的其他模块上；如果消息在新模块上没有被捕获的话就会再次进行传递；如果所有的消息都被捕获了的话，那我们的应用就应该已经按照代码进行了更新；反之如果有消息冒泡到了入口(entry)文件还没有被捕获的话，那就说明我们的代码中没有处理这类变更方法，那webpack就会刷新浏览器页面，即从HMR回退到LiveReload。</p>
<h2 id="-react-hmr">在React上实现HMR</h2>
<p>实现HMR时最复杂的地方是在应用层面上。现在在让我们看看如何在React上实现HMR。</p>
<p>虽然在上面的例子中，我们的SayHello.js就是React组件，但这里我实际上避开了在React上应用HMR时最困难的一点：我们应用的state。</p>
<p>如果我们把上面例子中的SayHello.js替换成一个计数器（Counter.js）的话：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }

  plusOne() {
    this.setState({
      count: this.state.count + this.props.valueAddEachClick * 2,
    });
  }

  render() {
    const valueAddEachClick = this.props.valueAddEachClick * 2;
    return (
      &lt;div&gt;
        &lt;label&gt;Value: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.plusOne.bind(this)}&gt;+{valueAddEachClick}&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>虽然HMR依然有效，但每次模块更新后，你会发现Counter的当前计数又会回到初始状态。因为在这一过程中，React组件中的state丢失了。</p>
<p>state丢失的原因和React的diff算法<label for="27" class="margin-toggle sidenote-number"></label><input type="checkbox" id="27" class="margin-toggle"/><span class="sidenote">关于React的diff算法，推荐看@vjeux的这篇<a href="http://calendar.perfplanet.com/2013/diff/">React’s diff algorithm</a></span> 有关。简单来说就是React在判断如何更新应用时，如果发现两个React Element类型不同的话，则会直接用新的React Element替换旧的React Element。</p>
<p>像我们在HMR的过程中更新了Counter.js模块，会重新生成新的Counter，实际上新的Counter和旧的Counter不是同一个Counter，即它们是不全等的。</p>
<p>所以在当前React没有提供任何相关api的状况下，如果我们仍想要保留原来的state的话，那我们就不能用新的组件直接替换旧的组件，即我们要保留原来组件的外壳，并更新其上的所有方法（利用mutable data）。同时因为数据没有发生变化，所以我们还需要某种方式来强制命令React更新应用的状态。</p>
<p>而这事实上就是react-proxy和react-deep-force-update的作用了。这两个库同样也是react-hot-loader和react-transform的依赖。由于这两个库的实现本身相对复杂费解，同时跟React内部的一些机制紧密相连，所以这里便不再深入了。</p>
<p>我们可以利用这两个库来完成帮助我们保留Counter的state：</p>
<pre><code class="lang-js">//entry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import Counter from &#39;./Counter&#39;;
import createProxy from &#39;react-proxy&#39;;
import deepForceUpdate from &#39;react-deep-force-update&#39;;

if (module.hot) {
  // module.hot.data是个{}，我们用它来在旧模块和新模块之间传递数据
  module.hot.data = module.hot.data || {};
  let {proxy, rootInstance} = module.hot.data;

  if (!proxy) {
    proxy = createProxy(Counter);
    const Component = proxy.get();

    rootInstance = ReactDOM.render(
      &lt;Component initialCount={10} valueAddEachClick={2}/&gt;,
      document.getElementById(&#39;main&#39;)
    );
  } else {
    proxy.update(Counter);
    deepForceUpdate(rootInstance);
  }

  module.hot.accept();

  module.hot.dispose(function(data) {
    // dispose方法用来定义一个一次性的函数，
    // 这个函数会在当前模块被更新之前调用。所以
    // 我们在这里，也就是proxy变量被销毁之前储存它。
    data.proxy = proxy;
    data.rootInstance = rootInstance;
  });
}
</code></pre>
<p>至此我们的代码也就小有所成了。</p>
<p><img src="/static/posts/webpack-hmr/complete-version.gif" alt="complete-version"></p>
<p>总结：</p>
<p>HMR很有意思，虽然它看起来象是个玩具一样，但事实上它确实能够提高我们的开发效率，因为它缩短了我们初始化应用及手动恢复应用状态的时间。特别是对web前端这样，UI代码占很重一部分工作，随时需要查看应用样式的编程任务来说，这点更为重要。</p>
<p>但现在要应用HMR，限制很多。不过本文截至时，@gaearon已经成了facebook的一员了，或许之后还能期待一下React在开发环境上为我们提供更多的可能性也说不定。</p>
]]></description>
            <link>https://blog.oyyd.net/post/how_does_react_hot_loader_works</link>
            <guid isPermaLink="false">632bf391d8f8f9e2d0678d8da613d395</guid>
            <pubDate>Thu, 03 Dec 2015 16:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>