<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[oyyd]]></title>
        <description><![CDATA[oyyd]]></description>
        <link>https://blog.oyyd.net</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Tue, 12 Jan 2016 05:38:38 GMT</lastBuildDate>
        <atom:link href="https://blog.oyyd.netdist/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— nunjucks]]></title>
            <description><![CDATA[<h1 id="-javascript-nunjucks">探究JavaScript上的编译器 —— nunjucks</h1>
<p>2016年01月12日</p>
<h2 id="-">写在前面的实践结果</h2>
<p>在前面<a href="https://blog.oyyd.net/post/javascript_compiler_marked">marked的学习过程</a>中，我简单地hack了marked来绑定了chartjs。但对于<a href="https://github.com/mozilla/nunjucks">nunjucks</a>，我没有想到比较好的实践方式。所以这次我将帮助修复nunjucks上的一些bug来作为本次实践。</p>
<p>到目前为止，已尝试修复的问题有：<a href="https://github.com/mozilla/nunjucks/pull/634">#571</a>, <a href="https://github.com/mozilla/nunjucks/pull/632">#332</a>, <a href="https://github.com/mozilla/nunjucks/pull/631">#595</a>, <a href="https://github.com/mozilla/nunjucks/pull/628">#612</a>, <a href="https://github.com/mozilla/nunjucks/pull/339">#317</a></p>
<h2 id="nunjucks-">nunjucks的代码结构</h2>
<p>nunjucks的整体代码结构如下：</p>
<p><img src="/static/posts/javascript-compiler/nunjucks.png" alt="nunjucks"></p>
<p>接下来再让我们看看每一部分的作用。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer中最主要的类被命名为Tokenizer，这听起来与Scanner异曲同工。</p>
<p>模板引擎的模板代码可以很容易地被分为成两种，一种将直接用于输出（即Lexer生成的TOKEN_DATA），另一种则可能有复杂的逻辑于其中。nunjucks在Lexer中有一个in_code属性用于储存当前的解析状态，并依次进行两套不同的解析规则。</p>
<p>下面展示了一段模板所生成的tokens：</p>
<pre><code class="lang-js">nunjucks.renderString(&#39;&lt;h1&gt; Hello, {{ me }}! &lt;/h1&gt;&#39;, { me: &#39;oyyd&#39; })

// 生成的tokens:
// { type: &#39;data&#39;, value: &#39;&lt;h1&gt; Hello, &#39;, lineno: 0, colno: 0 }
// { type: &#39;variable-start&#39;, value: &#39;{{&#39;, lineno: 0, colno: 12 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 12 }
// { type: &#39;symbol&#39;, value: &#39;me&#39;, lineno: 0, colno: 13 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 15 }
// { type: &#39;variable-end&#39;, value: &#39;}}&#39;, lineno: 0, colno: 16 }
// { type: &#39;data&#39;, value: &#39;! &lt;/h1&gt;&#39;, lineno: 0, colno: 16 }
</code></pre>
<p>Tokenizer只是将源码转换成tokens供其它代码使用。Tokenizer碰到什么字符就会试着把它转换成token，它不会参与任何高层次的逻辑，比如不会检查“{{”和“}}”是否配对。这一检查实际上是在Parser中进行的。</p>
<h3 id="parser">Parser</h3>
<p>Parser实际上是对tokens进行处理，以保证代码的语法规则合法，并据此生成由node组成的AST。</p>
<p>比如当出现“{{”时（TOKEN_BLOCK_START），Parser就会尝试在剩余的tokens中寻找“}}”（TOKEN_BLOCK_END）。如果没有找到，则Parser会认为代码不符合语法规则，从而抛出异常。</p>
<p>这里非常值得一提的是AST的生成方式。我们先来看看nunjucks尝试解析<code>or</code>的方法，注意代码中的注释：</p>
<pre><code class="lang-js">// ...
parseOr: function() {
    var node = this.parseAnd(); // 注意这里
    while(this.skipSymbol(&#39;or&#39;)) {
        var node2 = this.parseAnd(); // 注意这里
        node = new nodes.Or(node.lineno,
                            node.colno,
                            node,
                            node2);
    }
    return node;
},
// ...
</code></pre>
<p>我们可以看出在解析<code>or</code>之前，Parser首先会尝试解析<code>and</code>。而尝试解析<code>and</code>的代码如下：</p>
<pre><code class="lang-js">// ...
parseAnd: function() {
    var node = this.parseNot(); // 注意这里
    while(this.skipSymbol(&#39;and&#39;)) {
        var node2 = this.parseNot(); // 注意这里
        node = new nodes.And(node.lineno,
                             node.colno,
                             node,
                             node2);
    }
    return node;
},
// ...
</code></pre>
<p>和而如果你去看Parser尝试解析<code>not</code>的代码则会发现<code>parseNot</code>又会尝试先去解析其他语法。仔细思考一下<code>or</code>、<code>and</code>和<code>not</code>的关系你会发现他们是按照自己在语法中的优先级先后进行的，即Parser会优先尝试寻找高优先级的语法标识。并且对于AST来说，通常高优先级的语法只会是低优先级语法的子孙节点，比如对于：</p>
<pre><code class="lang-js">a and b or c
</code></pre>
<p>它的AST中<code>and</code>会是<code>or</code>的左子节点，即便调换他们的位置:</p>
<pre><code class="lang-js">a or b and c
</code></pre>
<p><code>and</code>仍旧是<code>or</code>的子节点，只不过变成了右子节点。</p>
<p>通过这样的做法，Parser将所有的tokens整合成了一棵树，而这棵树的根节点是全局只应有一个的<code>Root</code>。</p>
<p>如果你有兴趣了解得更仔细的话，可以看看下面的这个由Parser生成的AST。下面的模板代码：</p>
<pre><code class="lang-html">&lt;p&gt;
  Hi, I&#39;m
  {%if name and isNameValid or forceShowName%}
    &lt;span&gt;{{name}}&lt;/span&gt;
  {%endif%}
&lt;/p&gt;
</code></pre>
<p>生成的AST如下（注释为节点类型）：</p>
<pre><code class="lang-js">{ parent: undefined, // Root
  lineno: 0,
  colno: 0,
  children:
   [ { parent: undefined, // Output
       lineno: 0,
       colno: 0,
       children:
        [ { lineno: 0, colno: 0, value: &#39;&lt;p&gt;\n  Hi, I\&#39;m\n  &#39; }, // TemplateData
          [length]: 1 ] },
     { lineno: 2, // If
       colno: 2,
       cond:
        { lineno: 2, // Or
          colno: 5,
          left:
           { lineno: 2, // and
             colno: 5,
             left: { lineno: 2, colno: 5, value: &#39;name&#39; }, // Symbol
             right: { lineno: 2, colno: 14, value: &#39;isNameValid&#39; } }, // Symbol
          right: { lineno: 2, colno: 29, value: &#39;forceShowName&#39; } }, // Symbol
       body:
        { parent: undefined, // NodeList
          lineno: 0,
          colno: 0,
          children:
           [ { parent: undefined, // Output
               lineno: 2,
               colno: 42,
               children: [ { lineno: 2, colno: 42, value: &#39;\n    &lt;span&gt;&#39; }, [length]: 1 ] }, // TemplateData
             { parent: undefined, // Output
               lineno: 3,
               colno: 10,
               children: [ { lineno: 3, colno: 10, value: &#39;name&#39; }, [length]: 1] }, // Symbol
             { parent: undefined, // Output
               lineno: 3,
               colno: 14,
               children: [ { lineno: 3, colno: 14, value: &#39;&lt;/span&gt;\n  &#39; }, [length]: 1 ] }, // TemplateData
             [length]: 3 ] },
       else_: null },
     { parent: undefined, // Output
       lineno: 4,
       colno: 7,
       children: [ { lineno: 4, colno: 7, value: &#39;\n&lt;/p&gt;&#39; }, [length]: 1 ] }, // TemplateData
     [length]: 3 ] }
</code></pre>
<h3 id="compiler">Compiler</h3>
<p>Compiler使用AST生成中间代码。nunjucks运行在node上，所以nunjucks生成的中间代码自然就是JavaScript代码，这也意味着nunjucks可以运行在浏览器上。</p>
<p>AST中的nodes会被用来生成JavaScript代码片段，上文Parser中的那段模板代码生成的中间代码如下:</p>
<pre><code class="lang-js">function root(env, context, frame, runtime, cb) {
  var lineno = null;
  var colno = null;
  var output = &quot;&quot;;
  try {
    var parentTemplate = null;
    output += &quot;&lt;p&gt;\n  Hi, I&#39;m\n  &quot;;
    if (runtime.contextOrFrameLookup(context, frame, &quot;forceShowName&quot;) || runtime.contextOrFrameLookup(context, frame, &quot;name&quot;) &amp;&amp; runtime.contextOrFrameLookup(context, frame, &quot;isNameValid&quot;)) {
      output += &quot;\n    &lt;span&gt;&quot;;
      output += runtime.suppressValue(runtime.contextOrFrameLookup(context, frame, &quot;name&quot;), env.opts.autoescape);
      output += &quot;&lt;/span&gt;\n  &quot;;;
    }
    output += &quot;\n&lt;/p&gt;&quot;;
    if (parentTemplate) {
      parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);
    } else {
      cb(null, output);
    };
  } catch (e) {
    cb(runtime.handleError(e, lineno, colno));
  }
}
return {
  root: root
};
</code></pre>
<p>在Environment中，中间代码被作为函数体用来生成一个函数：</p>
<pre><code class="lang-js">var props = new Function(
  codeString // 中间代码
);
</code></pre>
<p>并且中间代码生成的函数将是个纯函数，传入同样的参数给它会得到同样的结果，这也就意味着在nunjucks中，编译的结果（到Compiler这一步的结果）可以被缓存起来，供以后直接使用，而不需要每次都进行编译。保存完编译结果以后以后，我们就不再需要模板了，而可以直接使用编译结果以提高性能并缩小浏览器上nunjucks文件的大小（即使用nunjucks-slim.js<label for="19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="19" class="margin-toggle"/><span class="sidenote">现在这个时间点nunjucks.min.js文件大小为69KB,nunjucks-slim.min.js大小为24KB</span> ）。这就是nunjucks中的precompile特性，也是提高模板引擎性能的关键。</p>
<h3 id="context-environment-template">Context &amp;&amp; Environment &amp;&amp; Template</h3>
<p>到目前为止，有了中间代码以后，我们只要传入参数就可以生成目标代码(HTML)了。而从外部传入的参数分为两种，上下文环境（渲染过程中直接使用到的变量等）储存在Context中，而配置等参数将被储存在Environment中。而Template最主要的目的则是组合使用Environment，其作用可以简单地理解为：</p>
<pre><code class="lang-js">return root( // root为中间代码生成的函数
  ctx, // 上下文环境
  env // 配置等
);
</code></pre>
<p>nunjucks提供给开发者的api和配置的相关代码大多应该可以在这里找到。</p>
<p>至此主要的编译过程也就结束了。</p>
<h2 id="-">其他</h2>
<p>事实上nunjucks还有不少高级特性值得探讨，比如async（transformer.js），它会改变parser的结构。这些内容就留待以后再探讨吧。</p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_nunjucks</link>
            <guid isPermaLink="false">a2c9ce9544918e833018f3c6ee9f6ab9</guid>
            <pubDate>Sun, 03 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— marked]]></title>
            <description><![CDATA[<h1 id="-javascript-marked">探究JavaScript上的编译器 —— marked</h1>
<p><strong>前言：</strong></p>
<p>如果你也用google去搜过编译相关的话题的话，会发现很难找到适合入门的内容。但与之相对的是，很多的库和特性的实现都离不开编译这一流程，我们去看一些开源的JavaScript代码时也经常会看到Lexer，Parser，Compiler，AST等东西。如果没有相关知识，那看这些代码时经常会一头雾水。</p>
<p>实际上在学习这部分内容时，可能阅读书籍(<a href="http://www.amazon.com/dp/0321486811/?tag=stackoverfl08-20">编译原理</a>)是最合适的。因为编译的原理基本相近，也没有随时间推移而发生大的改变，经典的书籍依旧非常适用，但这里将尝试通过一些开源项目的代码来学习编译。虽然这种学习方式可能不够详尽，容易遗漏内容，但它也更有利于我们学习到开发实践中常用的编译（它们的代码结构通常会更加简单），以及了解不同环境下的编译过程的设计。</p>
<p>但这个话题本身涉及的范围较广，内容较深，所以对这些内容的学习将通三个项目的源码进行，它们分别是：<a href="https://github.com/chjj/marked">marked</a> —— 它将markdown文本转换成可供浏览器使用的HTML标签, <a href="https://github.com/mozilla/nunjucks/">nunjucks</a> —— 模板引擎和<a href="http://zaach.github.io/jison/">Jison</a> —— 一个通用的parser生成器，三部分进行。</p>
<p>那这次让我们从marked开始。</p>
<h2 id="-">基础理论：一个编译器的结构</h2>
<p>首先还是让我们通过来粗略了解一下编译器的通用结构（摘自编译原理）：</p>
<ol>
<li><p>Lexical Analysis/Scanning（词法分析），在marked中由Lexer实现。</p>
</li>
<li><p>Syntax Analysis/Parsing（语法分析），在marked中由Parser实现。</p>
</li>
<li><p>Semantic Analysis（语义分析），代码优化，在marked中没有实现。</p>
</li>
<li><p>代码生成，在marked中由Parser和Renderer实现。</p>
</li>
</ol>
<h2 id="marked-">marked中的代码结构</h2>
<p>marked的目的是根据输入的markdown文本来输出可供浏览器解析的HTML内容，藉由：</p>
<pre><code class="lang-markdown"># 探究JavaScript上的编译器 —— marked

编译这个话题在JavaScript上很少出现...
</code></pre>
<p>生成类似这样的代码：</p>
<pre><code class="lang-html">&lt;h1&gt;探究JavaScript上的编译器 —— marked&lt;/h1&gt;
&lt;p&gt;
  编译这个话题在JavaScript上很少出现...
&lt;/p&gt;
</code></pre>
<p>编译目标的不同会直接使得我们代码结构大相径庭。所以对任何编译相关的代码，时刻明确我们的设计的目的可以很好地帮助我们理解代码。</p>
<p>marked由四部分组成，分别是: Lexer、InlineLexer、Parser、Renderer。</p>
<p><img src="/static/posts/javascript-compiler/marked_composition.png" alt="marked-composition"></p>
<p>其中Lexer会处理最原始的文本，它将文本处理、抽象，提供tokens供Parser使用；Renderer提供一组api供Parser和InlineLexer调用，以生成HTML；而Parser将对Lexer提供的tokens进行进一步处理，并据此调用Renderer中的api生成最终的HTML字符串。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer用来将源码转换成tokens供Parser使用，其表现如下：</p>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# title&#39;);

// tokens:  
// [ { type: &#39;heading&#39;, depth: 1, text: &#39;title&#39; } ]
</code></pre>
<p>Lexer生成的tokens事实上只是对源码的抽象和描述。通常tokens都会有一个属性来描述其“类型”（上面生成的tokens中的“type”属性），并有可能有一个或多个“值”属性来描述具体信息（上面tokens中的“title”和“title”属性）。</p>
<h3 id="inlinelexer">InlineLexer</h3>
<p>marked中还有InlineLexer，从名称上看我们可以猜测它的整体作用和Lexer相近。但InlineLexer是有两点不同：一是InlineLexer只用于处理诸如：<code>__strong__</code>、<code>~~line-through~~</code>这样的内联文本；二是InlineLexer不返回tokens给Parser使用，它会直接利用Renderer将源码转换成HTML内容。</p>
<pre><code class="lang-js">const output = marked.InlineLexer.output(&#39;__strong content__&#39;, {}, {});
// output: &#39;&lt;strong&gt;strong content&lt;/strong&gt;&#39;
</code></pre>
<p>所以Parser在处理内联文本时，是直接使用InlineLexer生成结果，而不是像Lexer一样依据tokens用Renderers生成HTML。</p>
<h3 id="renderer">Renderer</h3>
<p>在Parser之前，我们先来看看Renderer的表现。我们可以直接使用Renderer生成HTML:</p>
<pre><code class="lang-js">const options = {
  headerPrefix: &#39;header-id&#39;,
};
const renderer = new marked.Renderer(options);
const output = renderer.heading(&#39;hello world&#39;, 2, &#39;&#39;);

// output: &#39;&lt;h2 id=&quot;header-id&quot;&gt;hello world&lt;/h2&gt;&#39;
</code></pre>
<p>我们可以看到在marked中，Renderer上的方法生成的内容就是我们所期望的HTML内容了。</p>
<h3 id="parser">Parser</h3>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# hello world&#39;);
const output = marked.Parser.parse(tokens);
// output: &lt;h1 id=&quot;hello-world&quot;&gt;hello world&lt;/h1&gt;
</code></pre>
<p>因为markdown的语法规则不像编程语言一样复杂，所以marked中的Parser相对简单，基本上就是按顺序将tokens转换成转换成HTML内容。</p>
<h2 id="-marked">实践：扩展marked</h2>
<p>为了验证对marked的理解是否正确，我试着fork并修改了marked的代码（<a href="https://github.com/oyyd/marked-chartjs-binding">github地址</a>），绑定了chartjs，令我们可以在markdown中调用渲染图表。</p>
<p>你可以在这篇关于<a href="https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages">Universal React</a>的文章底部的benchmark部分看到柱状图。</p>
<p>在修改中，我加入了如下的语法：</p>
<pre><code class="lang-md">graph.chartName
// JSON data here which will be used by
endgraph
</code></pre>
<p>其中chartName将被用作chartjs的图表名，如：graph.Bar将使用chartjs中的Bar表。其对应的token形如：</p>
<pre><code class="lang-js">{
  type: &#39;graph&#39;,
  name: &#39;chartName&#39;, // chartn
  data: &#39;...&#39; // expecting JSON string containing `data` and `options` as the parameters of Chart
}
</code></pre>
<p>而在<code>graph.chartName</code>和<code>endgraph</code>之间的内容将作为图表的参数。修改过后的marked最终渲染出如下的内容：</p>
<pre><code class="lang-html">&lt;script type=&quot;text/chartdata&quot; data-chartname=&quot;chartName&quot;
  style=&quot;display:none;&quot;&gt;
// ...json string here
&lt;/script&gt;
</code></pre>
<p>事实上我们只是渲染了一个script标签来保留图表信息，修改过后的marked并不能让我们在浏览器上直接看到图表。这是由于浏览器的限制，涉及到script的内容在处理时会遇到各种问题，所以在我的处理里，我使用<code>renderCharts()</code>方法去文档中搜索这样的标签，从而真正地渲染图表。</p>
<h2 id="-">相关链接</h2>
<p><a href="http://programmers.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler">How to write a very basic compiler</a></p>
<p><a href="http://stackoverflow.com/questions/2842809/lexers-vs-parsers">lexers vs parsers</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_marked</link>
            <guid isPermaLink="false">d1d5084ec80418fd578b0a8d67e82bcc</guid>
            <pubDate>Sun, 03 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究用ES6 template strings替代前后端模板引擎]]></title>
            <description><![CDATA[<h1 id="-es6-template-strings-">探究用ES6 template strings替代前后端模板引擎</h1>
<p><strong>前言：</strong></p>
<p>JavaScript上有很多的模板引擎，不管是用于前端的、后端的、两者兼顾的，或是特性丰富的，或是在模板中尽可能减少逻辑的，选择十分丰富。如果你也曾在一个或大或小的项目中考虑如何选择模板引擎的话，那你肯定也和我一样犹豫过要怎么选择。</p>
<p>另一方面，在我大量使用React的工作时间中，我越发认可React中jsx的设计$sidenote(<a href="http://blog.vjeux.com/2013/javascript/jsx-e4x-the-good-parts.html">JSX: E4X The Good Parts</a>
)。而当我从React jsx的角度考虑一个好的模板引擎应该具有什么样的特性时，我意识到，对于比较简单的情形，使用ES6中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template strings</a>外加一些约定就已经足矣。你甚至不需要模板引擎就能够很好地处理绝大多数你以前需要用模板引擎来处理的工作。</p>
<p>那么下面就让我们来简单地探讨一下用ES6 template strings替代模板引擎的可行性及其优劣。</p>
<h2 id="-">一个简单的实例</h2>
<p>像是我的这个博客的一部分模板工作是直接利用template strings完成的（剩下的是React renderToString完成的）：</p>
<p>head标签的模板:</p>
<pre><code class="lang-js">// createHead.js
function createHead(ctx) {
  let {title, description} = ctx;

  return (
    `&lt;head&gt;
      &lt;title&gt;${title}&lt;/title&gt;
      &lt;meta name=&quot;description&quot; content=&quot;${description}&quot;/&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
      &lt;link rel=&quot;shortcut icon&quot; href=&quot;/static/favicon.ico&quot; /&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/codemirror.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/theme/monokai-sublime.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
    &lt;/head&gt;`
  );
}

export default createHead;
</code></pre>
<p>使用head标签模板，并引入每个页面的具体内容：</p>
<pre><code class="lang-js">// createPage.js
import createHead from &#39;./createHead&#39;;

function createPage(ctx) {
  let {title, description, content, initialState} = ctx;

  title = title || &#39;oyyd blog&#39;;
  description = description || &#39;这是亚东的博客，你可以在上面看到我的一些想法和实践，欢迎来访。&#39;;
  initialState = initialState || &#39;null&#39;;

  return (
    `&lt;!DOCTYPE html&gt;
    &lt;html&gt;
      ${createHead({title, description})}
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${content}&lt;/div&gt;
        &lt;script&gt;
          window.__INITIAL_STATE__ = JSON.parse(&quot;${initialState}&quot;);
        &lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/codemirror.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/javascript/javascript.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/xml/xml.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          (function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);

          ga(&#39;create&#39;, &#39;UA-70462946-1&#39;, &#39;auto&#39;);
          ga(&#39;send&#39;, &#39;pageview&#39;);
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
}

export default createPage;
</code></pre>
<p>这样，我们就在没有引入模板引擎的情况下，完成了这些简单的工作。</p>
<h2 id="-api-">对比实现其他模板引擎中的一些API与特性</h2>
<p>为了进一步探讨用template strings替代模板引擎的可行性，我们将对比实现其他模板引擎中的一些特性。</p>
<p>这里我们挑选的是<a href="http://mozilla.github.io/nunjucks/templating.html">nunjucks</a>中的一些特性，因其特性相对强大，更容易帮助我们说明template strings的特点及局限性。</p>
<p>另外，如果有些什么是template strings没有，而其他模板引擎做得到的话，你可以考虑用其他javascript的方式来实现，毕竟 <strong>你可以直接使用javascript这一强大的语言环境，通常再写一个函数/模板都能解决你的问题</strong>。并且相比于评价其好坏，你可能更需要去思考一下你是否真的需要这一特性。</p>
<h3 id="-">表达式</h3>
<p>nunjucks:</p>
<pre><code class="lang-html">{{ numItems*2 }}
</code></pre>
<p>template strings本身接受的就是表达式：</p>
<pre><code class="lang-js">`
${ numItems * 2 }
`
</code></pre>
<h3 id="if-else">if else</h3>
<p>nunjucks中的条件语句十分灵活：</p>
<pre><code class="lang-html">{% if hungry %}
  I am hungry
{% elif tired %}
  I am tired
{% else %}
  I am good!
{% endif %}
</code></pre>
<p>因为template strings只接受表达式的值，所以你最多只能用boolean-exp：</p>
<pre><code class="lang-js">`
${ hungry ? (
  I am hungry
) : (
  I am not hungry
) }
`
</code></pre>
<h3 id="for">for</h3>
<p>假设我们有：</p>
<pre><code class="lang-js">var points = [[0, 1, 2], [5, 6, 7], [12, 13, 14]];
</code></pre>
<p>在nunjucks中的：</p>
<pre><code class="lang-html">{% for x, y, z in points %}
  Point: {{ x }}, {{ y }}, {{ z }}
{% endfor %}
</code></pre>
<p>虽然template strings只接受表达式，但还是可以这样完成实现:</p>
<pre><code class="lang-js">`${points.map(({x, y, z}) =&gt; (
  `Point: ${x}, ${y}, ${z}`
)).join(&#39;&#39;)}`
</code></pre>
<h3 id="-asynceach-asyncall">异步操作asyncEach与asyncAll</h3>
<p>nunjucks支持一些异步操作：</p>
<pre><code class="lang-html">&lt;h1&gt;Posts&lt;/h1&gt;
&lt;ul&gt;
{% asyncAll item in items %}
  &lt;li&gt;{{ item.id | lookup }}&lt;/li&gt;
{% endall %}
&lt;/ul&gt;
</code></pre>
<p>我们没办法直接在template strings中做这件事。但如果只是进行简单的异步操作的话，我们可以在外部进行处理，并且这和其他用javascript处理异步操作的情况一致：</p>
<pre><code class="lang-js">function renderPosts(posts) {
  return new Promise((resolve, reject) =&gt; {
    let content = &#39;&#39;;

    // 写些异步操作来修改content
    // ...

    resolve(`
      &lt;h1&gt;Posts&lt;/h1&gt;
      &lt;ul&gt;
        ${content}
      &lt;/ul&gt;
    `);
  });
}
</code></pre>
<p>但如果想要我们的模板整体支持异步的话，我们就需要写一些额外的代码来做这件事。而避免在你的模板中使用异步操作也是个选择。</p>
<h3 id="autoescaping">Autoescaping</h3>
<p>在nunjucks中，当<code>autoescape</code>选项被设置为<code>true</code>时，nunjucks会默认地转义变量的值，以防止可能来自用户的攻击。在使用template strings时，我们不难转义单个变量的值：</p>
<pre><code class="lang-js">var username = &#39;&lt;script&gt;&lt;/script&gt;&#39;;

function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

return `&lt;div&gt;{ escapeHTML(username) }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>而如果我们不想每次都手动调用转义函数，而是想要默认转义所有变量的值的话，我们可以利用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings">Tagged template strings</a>这一特性：</p>
<pre><code class="lang-js">function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${str}` : `${str}${escapeHTML(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`&lt;div&gt;{ uesrname }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>Tagged template strings这一特性很强大，你需要去充分利用它<label for="20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="20" class="margin-toggle"/><span class="sidenote">Tagged templates invite library designers to create powerful domain-specific languages. ——<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/">ES6 In Depth: Template strings</a></span> 。</p>
<h3 id="comments">comments</h3>
<p>在nunjucks中我们可以写注释：</p>
<pre><code class="lang-html">{# Loop through all the users #}
{% for user in users %}...{% endfor %}
</code></pre>
<p>并且模板中的注释在生成的字符串中会被自动截掉。如果我们想在template strings中写注释的话，我们就需要直接写成HTML的注释：</p>
<pre><code class="lang-js">`
&lt;!-- Loop through all the users --&gt;
`
</code></pre>
<p>那么我们能否在模板生成的字符串中自动截取掉这些注释呢？那我们还是要利用tagged template strings：</p>
<pre><code class="lang-js">function trimComments(str) {
  return str.replace(/&lt;!--.*?--&gt;/g, &#39;&#39;);
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${trimComments(str)}` : `${trimComments(str)}${trimComments(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`
  &lt;!-- Loop through all the users --&gt;
`;
</code></pre>
<h3 id="-">动态生成模板</h3>
<p>大部分模板引擎都可以动态生成模板，因为生成模板的过程实际上是在js上进行的一次编译过程，比如在nunjucks中：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;Hello {{ username }}&#39;;
var res = nunjucks.renderString(template, { username: username });
</code></pre>
<p>我们可以通过eval方法来动态生成模板：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;`Hello ${ username }`&#39;;
// 你应该需要更稳健的写法
var res = eval(template);
</code></pre>
<h2 id="-template-strings-">用template strings替代模板引擎的优点和缺点</h2>
<p>到目前位置，我们主要讨论了用template strings来替代模板引擎的可行性，下面我们会讨论这样做的优点和缺点。</p>
<p>模板引擎是<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>，其目的是拼接字符串。没有模板引擎我们当然也可以拼接字符串，只不过这一过程会很痛苦。而template strings本身就是为了解决这一问题而设计的，而tagged template strings又足够帮助我们实现模板引擎的功能<label for="21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="21" class="margin-toggle"/><span class="sidenote">利用tagged template strings开发DSL当然也是可行的，这里的讨论不涉及开发DSL的情况</span> 。</p>
<p>由于各种原因，通常模板引擎在处理很多问题时，通常会有自己的一套方法，比如说在一个模板中引入另一个模板你可能需要用import/require/partials语句，这实际上和JavaScript本身的import解决的是相似的问题。所以在使用template strings时，面对这些情况，我们就可以直接利用JavaScript中的特性来实现，而不需要像那样用一套新的东西来解决相似的问题。</p>
<p>这样很自然地，使用template strings替代模板引擎最主要的优点在于：</p>
<ol>
<li><p>贴近原生JavaScript，学习曲线更低。</p>
</li>
<li><p>你可以充分利用已有的JavaScript代码和特性，任何新的需求都可以通过你熟悉的JavaScript进行拓展。</p>
</li>
<li><p>你的模板部分的内容天然就是Universal JavaScript，你天然地就可以同时在浏览器上和服务器上使用模板相关的代码。</p>
</li>
</ol>
<p>但模板引擎毕竟是专门为处理模板而生的，有些用JavaScript实现比较麻烦的场景，用模板引擎的语法可能可以轻松地解决。实际上这里的讨论更像是在讨论使用DSL的优缺点。但使用template strings的理由在于 <strong>很多模板引擎上的很多特性都和JavaScript（ES6+）本身的特性重合了，我们没必要用一套新东西解决同样的问题</strong>。当然在ES6之前，JavaScript本身也没有模块，更别说考虑直接使用JavaScript中的特性来解决模板上的问题。</p>
<p>而另一个推荐使用template strings的原因在于Universal JavaScript。如果模板本身就是JavaScript代码的话，那么在前后端同时使用一份代码会变得容易得多。</p>
<p>另外不分离模板与代码的这一想主要是受到React的启发。React中的HTML(Virtual DOM, React DOM)部分和JavaScript代码紧密贴合<label for="22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="22" class="margin-toggle"/><span class="sidenote">这里主要是对比Angular和Polymer等框架，即主要由JavaScript代码控制HTML内容，而不是以HTML为主，也不是HTML和JavaScript平分秋色</span> 的想法，至少从实践角度上来说是很有效的，它使得代码十分容易维护。那么对于模板来说，不去刻意分离模板代码与普通的代码、模板代码既是JavaScript代码或许是个好的思路。</p>
<h2 id="-">生产环境上的应用</h2>
<p>在生产环境上单单使用template strings没办法解决我们的所有需求，而截止至本文时点我也没有看见过任何类似的实现。所以如果你觉得这是个好主意，你需要充分利用tagged template strings这一特性来组织起模板层。万幸的是这一过程不需要涉及编译，所以这会远比重新写一个模板引擎要简单得多。之后我也会尝试写一个帮助实现这一目的的库。</p>
<h2 id="-">其他相关链接</h2>
<p><a href="http://www.2ality.com/2015/01/template-strings-html.html">HTML templating with ES6 template strings</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/best_template_engine_in_node_js</link>
            <guid isPermaLink="false">e376e1b601f9fe30966dd8f5ca201e23</guid>
            <pubDate>Tue, 15 Dec 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究Webpack中的HMR(hot module replacement)]]></title>
            <description><![CDATA[<h1 id="-webpack-hmr-hot-module-replacement-">探究Webpack中的HMR(hot module replacement)</h1>
<p>2015年12月04日</p>
<p>什么是HMR？HMR能做什么？我们可以看看react-transform的演示：
<img src="/static/posts/webpack-hmr/react-transform-example.gif" alt="react-transform-example"></p>
<p>react-transform的实现是基于webpack-dev-server之上的，这里我将从webpack-dev-server和React两方面简单总结HMR的实现原理。</p>
<p>（<a href="https://github.com/oyyd/oyyd-blog/tree/master/research/react-hot-loader">从这里查看下文中的部分代码</a>）</p>
<h2 id="-webpack-dev-server-">从webpack-dev-server开始</h2>
<p>webpack不仅能够起到打包的作用，它还“附带了”一个专门用于开发的、由express构建的迷你服务器，即webpack-dev-server。webpack-dev-server的基本作用是处理我们的打包任务，并且它还会作为一个静态文件服务器提供我们最新打包成的静态文件供本地开发使用。webpack-dev-server与我们平时开发用的静态文件服务器的不同之处在于，它知道新的文件在何时被打包了出来，以及究竟是哪个文件发生了改变。</p>
<p>在“webpack-dev-server知道何时新文件会被打包出来的”这个基础之上，webpack-dev-server可以和浏览器之间建立一个web socket进行通信，一旦新文件被打包出来，webpack-dev-server就告诉浏览器这个消息，这时浏览器就可以自动刷新页面<label for="23" class="margin-toggle sidenote-number"></label><input type="checkbox" id="23" class="margin-toggle"/><span class="sidenote">或是刷新iframe</span> ，而不用等到开发者手动刷新。</p>
<p><img src="/static/posts/webpack-hmr/hot-reload.gif" alt="complete-version"></p>
<p>对的，到这里webpack实际上已经实现了<a href="http://livereload.com/">livereload</a>的功能。</p>
<h2 id="-hmr-api">使用HMR的相关api</h2>
<p>webpack知道是哪个模块发生了改变，并且还提供了api帮助我们更新应用的状态。在这基础之上，只要我们知道要怎么用更新后的模块来更新我们的应用，我们就不需要刷新页面来重新加载整个应用了。</p>
<p>比如说我们需要使用一个模块A，这个模块A是个React Component，用来在页面上渲染<code>hello world</code>。对于这个简单的React Component来说，我们只需要在它更新以后重新渲染就能够保持应用的状态，而不需要其他工作。所以我们可以像下面这样做：</p>
<p>我们的SayHello.js文件：</p>
<pre><code class="lang-js">// SayHello.js
import React from &#39;react&#39;;

const color = &#39;black&#39;;

class SayHello extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div style={{color: color}}&gt;Hello, {this.props.name}!&lt;/div&gt;
    );
  }
}

export default SayHello;
</code></pre>
<p>我们的sayHelloEntry.js，</p>
<pre><code class="lang-js">// sayHelloEntry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import SayHello from &#39;./SayHello&#39;;

const name = &#39;world&#39;;

function renderComponent(RootComponent) {
  ReactDOM.render(
    &lt;RootComponent name={name}/&gt;,
    document.getElementById(&#39;main&#39;)
  );
}

// 通过module.hot获取webpack提供的一系列的api
if (module.hot) {
  module.hot.accept(); // 接受模块更新的事件，同时阻止这个事件继续冒泡
  renderComponent(SayHello); // 进行渲染
} else {
  // 非HMR状态下的代码
  renderComponent(SayHello);
}
</code></pre>
<p>在浏览器上加载这个页面后，我们就可以尝试修改sayHelloEntry.js模块中的<code>name</code>的值或是SayHello.js模块中的内容来查看结果：</p>
<p><img src="/static/posts/webpack-hmr/simple-version.gif" alt="complete-version"></p>
<p>虽然这个例子非常简单，但它也足以说明在webpack中的HMR的基本原理了。而你也应该很快注意到了，虽然在开发过程中，所有模块都有可能发生改变，但我们并不需要为每个模块写HMR代码。</p>
<p>那么当没有HMR相关代码的模块发生改变时，我们的应用到底是怎么运作的呢？这就是webpack HMR中的消息<label for="24" class="margin-toggle sidenote-number"></label><input type="checkbox" id="24" class="margin-toggle"/><span class="sidenote">称为消息可能并不合适，但下文就这么用吧</span> 冒泡（bubble up）机制。</p>
<p><img src="/static/posts/webpack-hmr/bubble-up.png" alt="bubble-up"></p>
<p>当一个模块C发生改变，而模块内又没有HMR代码来处理这一消息时，那这一消息就会被传递到依赖模块C的其他模块上；如果消息在新模块上没有被捕获的话就会再次进行传递；如果所有的消息都被捕获了的话，那我们的应用就应该已经按照代码进行了更新；反之如果有消息冒泡到了入口(entry)文件还没有被捕获的话，那就说明我们的代码中没有处理这类变更方法，那webpack就会刷新浏览器页面，即从HMR回退到LiveReload。</p>
<h2 id="-react-hmr">在React上实现HMR</h2>
<p>实现HMR时最复杂的地方是在应用层面上。现在在让我们看看如何在React上实现HMR。</p>
<p>虽然在上面的例子中，我们的SayHello.js就是React组件，但这里我实际上避开了在React上应用HMR时最困难的一点：我们应用的state。</p>
<p>如果我们把上面例子中的SayHello.js替换成一个计数器（Counter.js）的话：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }

  plusOne() {
    this.setState({
      count: this.state.count + this.props.valueAddEachClick * 2,
    });
  }

  render() {
    const valueAddEachClick = this.props.valueAddEachClick * 2;
    return (
      &lt;div&gt;
        &lt;label&gt;Value: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.plusOne.bind(this)}&gt;+{valueAddEachClick}&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>虽然HMR依然有效，但每次模块更新后，你会发现Counter的当前计数又会回到初始状态。因为在这一过程中，React组件中的state丢失了。</p>
<p>state丢失的原因和React的diff算法<label for="25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="25" class="margin-toggle"/><span class="sidenote">关于React的diff算法，推荐看@vjeux的这篇<a href="http://calendar.perfplanet.com/2013/diff/">React’s diff algorithm</a></span> 有关。简单来说就是React在判断如何更新应用时，如果发现两个React Element类型不同的话，则会直接用新的React Element替换旧的React Element。</p>
<p>像我们在HMR的过程中更新了Counter.js模块，会重新生成新的Counter，实际上新的Counter和旧的Counter不是同一个Counter，即它们是不全等的。</p>
<p>所以在当前React没有提供任何相关api的状况下，如果我们仍想要保留原来的state的话，那我们就不能用新的组件直接替换旧的组件，即我们要保留原来组件的外壳，并更新其上的所有方法（利用mutable data）。同时因为数据没有发生变化，所以我们还需要某种方式来强制命令React更新应用的状态。</p>
<p>而这事实上就是react-proxy和react-deep-force-update的作用了。这两个库同样也是react-hot-loader和react-transform的依赖。由于这两个库的实现本身相对复杂费解，同时跟React内部的一些机制紧密相连，所以这里便不再深入了。</p>
<p>我们可以利用这两个库来完成帮助我们保留Counter的state：</p>
<pre><code class="lang-js">//entry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import Counter from &#39;./Counter&#39;;
import createProxy from &#39;react-proxy&#39;;
import deepForceUpdate from &#39;react-deep-force-update&#39;;

if (module.hot) {
  // module.hot.data是个{}，我们用它来在旧模块和新模块之间传递数据
  module.hot.data = module.hot.data || {};
  let {proxy, rootInstance} = module.hot.data;

  if (!proxy) {
    proxy = createProxy(Counter);
    const Component = proxy.get();

    rootInstance = ReactDOM.render(
      &lt;Component initialCount={10} valueAddEachClick={2}/&gt;,
      document.getElementById(&#39;main&#39;)
    );
  } else {
    proxy.update(Counter);
    deepForceUpdate(rootInstance);
  }

  module.hot.accept();

  module.hot.dispose(function(data) {
    // dispose方法用来定义一个一次性的函数，
    // 这个函数会在当前模块被更新之前调用。所以
    // 我们在这里，也就是proxy变量被销毁之前储存它。
    data.proxy = proxy;
    data.rootInstance = rootInstance;
  });
}
</code></pre>
<p>至此我们的代码也就小有所成了。</p>
<p><img src="/static/posts/webpack-hmr/complete-version.gif" alt="complete-version"></p>
<p>总结：</p>
<p>HMR很有意思，虽然它看起来象是个玩具一样，但事实上它确实能够提高我们的开发效率，因为它缩短了我们初始化应用及手动恢复应用状态的时间。特别是对web前端这样，UI代码占很重一部分工作，随时需要查看应用样式的编程任务来说，这点更为重要。</p>
<p>但现在要应用HMR，限制很多。不过本文截至时，@gaearon已经成了facebook的一员了，或许之后还能期待一下React在开发环境上为我们提供更多的可能性也说不定。</p>
]]></description>
            <link>https://blog.oyyd.net/post/how_does_react_hot_loader_works</link>
            <guid isPermaLink="false">632bf391d8f8f9e2d0678d8da613d395</guid>
            <pubDate>Thu, 03 Dec 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ Universal(Isomorphic) JavaScript在React上的应用]]></title>
            <description><![CDATA[<h1 id="universal-isomorphic-javascript-react-">Universal(Isomorphic) JavaScript在React上的应用</h1>
<p>2015年11月26日</p>
<p>React中的renderToString方法允许我们在服务器上渲染React部件，这点不仅可以帮助我们解决一些会出现在单页应用(SPA)上的问题，它甚至还允许我们将React用作模板引擎（template engine）来使用。下文还将附带一个简单的benchmark来对比React与传统模板引擎之间性能。</p>
<h2 id="-universal-javascript-">什么是Universal Javascript？</h2>
<p>Universal Javascript又称Isomorphic JavaScript<label for="26" class="margin-toggle sidenote-number"></label><input type="checkbox" id="26" class="margin-toggle"/><span class="sidenote"><a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9">两个名称的来由</a></span> ，是指可以运行在客户端和服务器上的javascript代码。<label for="27" class="margin-toggle sidenote-number"></label><input type="checkbox" id="27" class="margin-toggle"/><span class="sidenote"><a href="http://isomorphic.net/">http://isomorphic.net</a></span> </p>
<p>实现Universal Javascript的原理并不复杂，我们只需要在代码中获取当前运行环境（浏览器还是服务器？），并根据环境作出不同响应即可。比如在<a href="https://www.meteor.com/">Meteor</a>中，你会看到这样的代码出现在同一个文件中：</p>
<pre><code class="lang-js">if (Meteor.isServer) {
  // This code only runs on the server
}

if (Meteor.isClient) {
  // This code only runs on the client
}
</code></pre>
<p>只要通过<code>Meteor.isServer</code>和<code>Meteor.isClient</code>，我们就能够控制代码在不同环境下的逻辑，从而使得这份代码可以同时在客户端和服务器上执行，并根据环境返回对应的结果。</p>
<h2 id="universal-javascript-react-">Universal JavaScript可以给React应用带来什么？</h2>
<p>那么对于React来讲，Universal Javascript又有什么用呢?我们知道，html标签加载了一部分就会显示一部分； 而React是通过javascript来渲染html内容的。这也就意味着在完成脚本的加载和运行之前，React应用中的html内容是不会出现在页面上的。</p>
<p>像是本站blog.oyyd.net原来是用React + React Router写的SPA(单页)应用，页面内容是这样的：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;oyyd blog - 这是亚东的博客（偏技术），你可以在上面看到我的一些想法和实践，欢迎来访。&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;meta name=&quot;description=&quot; content=&quot;内容偏前端，但不局限于前端，没准你会感兴趣。&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以看到代码中基本没有与内容相关的html标签，这就导致SPA一直存在的一些<strong>问题</strong>：</p>
<ol>
<li><p>用户在脚本加载运行之前是不会看到React部分的内容，从体验上来讲好像等待了更多的时间（特别是在网速差的时候）。</p>
</li>
<li><p>如果javascrript加载失败或是运行时产生错误的话（或是浏览器直接禁用了javascript的话），用户看不到任何内容。</p>
</li>
<li><p>搜索引擎无法有效地爬取页面内容<label for="28" class="margin-toggle sidenote-number"></label><input type="checkbox" id="28" class="margin-toggle"/><span class="sidenote">对于google而言，有一些<a href="https://developers.google.com/webmasters/ajax-crawling/docs/getting-started">解决办法</a>来引导爬虫去另一个事先准备好页面内容的地方</span> ，难以进行SEO。</p>
</li>
</ol>
<p>对于这些问题，我们可以利用Universal JavaScript，也即React中的<code>renderToString</code>方法，在服务器上就渲染出React应用中的部分内容返回给浏览器，从而解决这些问题。</p>
<h2 id="-">实现</h2>
<p>现在的blog.oyyd.net就充分利用了React中的<code>renderToString</code>。你可以在浏览器中查看源码来查看这个网站现在的状况。接下来还是让我们通过一个更加简洁的例子来了解这一流程：</p>
<blockquote>
<p>注意：下面的代码并不完备，由于构建过程相对繁杂多样，所以这些代码更多是为了让我们能更好地关注这一流程中的重点步骤。</p>
</blockquote>
<p>假设我们要实现一个简单的计数器，这个计数器的初始值会在服务器端就设置好。</p>
<p>整个流程大致如下：</p>
<ol>
<li><p>请求到来，服务器初始化我们的React计数器，并将其渲染成字符串。</p>
</li>
<li><p>把React生成的字符串和计数器的初始值放到模板中，合并成完整的HTML内容返回给浏览器。</p>
</li>
<li><p>在浏览器上，利用计数器的初始值初始化React应用。</p>
</li>
</ol>
<p>其中我们的React计数器代码如下：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props){
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }
  countPlusOne(){
    this.setState({
      count: this.state.count + 1,
    });
  }
  render(){
    return (
      &lt;div&gt;
        &lt;label&gt;数值: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.countPlusOne.bind(this)}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Counter;
</code></pre>
<p>当请求来临时，express根据参数设置初始状态生成一个Counter的ReactElement,并将其渲染成字符串：</p>
<pre><code class="lang-js">// server.js
import fs from &#39;fs&#39;;
import express from &#39;express&#39;;
import React from &#39;react&#39;;
import {renderToString} from &#39;react-dom/server&#39;;

import Counter from &#39;./components/Counter&#39;;

const app = express();
app.get(&#39;/:initialCount&#39;, (req, res) =&gt; {
  const {initialCount} = req.params;

  // 生成Counter实例的字符串
  const counterString = renderToString(
    &lt;Counter initialCount={initialCount}/&gt;
  );

  // 注意下面不仅将Counter的字符串放入了html内容中，并且
  // 还将参数保存在了全局浏览器上的全局变量`__INITIAL_COUNT__`
  req.send(
    `&lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${counterString}&lt;/div&gt;
        &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          window.__INITIAL_COUNT__ = ${initialCount};
        &lt;/script&gt;
        &lt;script src=&quot;/bootstrap.js&quot;&gt;&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
});

app.listen(8080);
</code></pre>
<p>当浏览器上的请求从服务器上返回时，bootstrap.js脚本被加载运行，在浏览器上初始化完整的React应用：</p>
<pre><code class="lang-js">// bootstrap.js
React.render(
  &lt;Counter initialCount={window.__INITIAL_COUNT__}/&gt;,
  document.getElementById(&#39;main&#39;)
);
</code></pre>
<p>到这里，我们的计数器应用就顺利地加载在了浏览器上，并且这一次，我们的页面一开始不会像SPA应用那样空空如也。</p>
<p>这一过程就像是我们的React应用的初始化过程被分成了两次进行。先是在服务器上，我们初始化了React应用中的HTML的内容，并发送到前端；然后浏览器接过了这些内容，继续进行DOM事件绑定等工作。而值得注意的是，为了能在前端以正确的初始状态启动应用，我们需要把我们应用的状态（上面例子中的<code>window.__INITIAL_COUNT__</code>）也一并传过去，用于初始化。</p>
<h2 id="-react-">事实上，我们在用React替代服务器端的模板引擎</h2>
<p>如果你回想一下这一过程，你可能会注意到在这一流程中，React承担起了服务器上本应由模板引擎处理的(template engine)大部分工作<label for="29" class="margin-toggle sidenote-number"></label><input type="checkbox" id="29" class="margin-toggle"/><span class="sidenote"><del>现在的React是无法生成<code>html</code>, <code>script</code>等标签的</del>很惭愧，事实上是可以的。</span> 。</p>
<p>如果你写过服务器端模板，同时也很熟悉React，那你可能会和我有同样的感受：React中的模板（或者说是jsx）用起来甚至比专业的模板引擎更加顺手。因为使用模板引擎意味着你在用一门模板语言和javascript交互；而React本身就是javascript，jsx本质也是javascript，所以React中的“模板”用起来要自然得多。</p>
<p>如果你只需要静态页面的话，你完全可以写一些没有state的React部件来承担服务器上模板引擎的大部分工作。事实上现在已经有<a href="https://github.com/reactjs/express-react-views">express-react-views</a>这样的库来实现这一目的<label for="30" class="margin-toggle sidenote-number"></label><input type="checkbox" id="30" class="margin-toggle"/><span class="sidenote">其作者也是React的维护者<a href="https://github.com/zpao">@zpao</a></span> 。</p>
<p>那么让一门前端框架作为模板引擎是不是多余之举呢？</p>
<p>事实可能完全相反。因为浏览器上js所使用的模板和服务器上渲染的模板原本就应该是同一份模板，它们同属于我们浏览器上的应用。只不过由于种种原因，我们一直不得不将其拆分成两部分。那么现在如果服务器的这份模板由本身就主要用于浏览器上的React来生成的话，我觉得是再合理不过的了。</p>
<p><img src="/static/posts/react-server-render/react-as-template-engine.png" alt="React as Template Engine"></p>
<p><del>当然因为React无法生成所有常用的标签，所以你可能还是需要模板引擎来帮你处理React应用之外的工作。</del>一般我们用在浏览器上的React应用不会用到诸如：html，script，body这样的标签，但我们可以在服务器渲染时使用他们来生成完整的内容。</p>
<p>并且这样做，我们可以充分利用同一份代码，技术栈也会变得更加简单。想象一下，没有html、template、ejs、jade等文件，你的js文件就是你的模板文件，你可以直接利用js上的模块等特性，这能够省多少事！</p>
<p>但是如果你把之前用于浏览器上的React部件直接拿来服务器渲染的话，你可能没办法如愿。举个例子：在浏览器上你很可能在会直接使用全局变量window，但在node上这会抛出错误。你需要在写你的应用的时候就考虑清楚一个部件在服务器上渲染时的情况。</p>
<p>而你的React部件拥有state的话，你是没办法直接控制他们的状态的。但如果你使用<a href="https://github.com/rackt/redux">Redux</a>来将部件中的state移动到外部的话，你就可以通过Redux来从外部自由控制你部件的状态，也就可以控制服务器端渲染的内容了。</p>
<h2 id="-benchmark">一个简单的benchmark</h2>
<p>React不是纯粹的模板引擎，那么与node上其他的模板引擎相比，它的server render的性能会不会差很多呢？这里我们将前面的计数器代码做一下改动，通过一个小范围的、非常简单的benchmark来对比React和ejs之间性能的量级：</p>
<blockquote>
<p>这里还是要再次强调：这个benchmark的目的只是在于帮助我们了解他们之间大概的性能，实际应用时的状况很可能不是这样的。</p>
</blockquote>
<p>设备：Windows 8.1 Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz 2.59GHz  8.00GB</p>
<p>版本：React 14.0.2，ejs 2.3.4</p>
<p>ejs使用的模板文件：</p>
<pre><code class="lang-html">&lt;div&gt;
  &lt;label&gt;数值:&lt;%=count%&gt;&lt;/label&gt;
  &lt;button&gt;+1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>React Counter(es6中类的形式)<label for="31" class="margin-toggle sidenote-number"></label><input type="checkbox" id="31" class="margin-toggle"/><span class="sidenote">下面的代码都使用了babel进行转换，可能对结果会产生一些影响</span> ：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>React Counter(传统方式)：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

const Counter = React.createClass({
  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  },
});

export default Counter;
</code></pre>
<p>测试时的渲染语句：</p>
<pre><code class="lang-js">// React
renderToString(&lt;Counter count={10}/&gt;);

// ejs
ejs.render(template, {
  count: 10,
});
</code></pre>
<p>设置node环境为<code>production</code>，避免React做一些用于开发环境的工作，并开始渲染：</p>
<pre><code>NODE_ENV=production node lib/index.js
</code></pre><p>结果如下：</p>
<p>数值单位是ope/sec（每秒渲染数）越高越好</p>
<script type="text/chartdata" data-chartname="Bar" style="display:none;">{
  "options": {
    "multiTooltipTemplate": "<%= datasetLabel %>:<%= value %>"
  },
  "data": {
      "labels": ["第1次", "第2次", "第3次", "第4次", "第5次"],
      "datasets": [
          {
              "label": "React ES6 class",
              "fillColor": "rgba(220,220,220,0.5)",
              "strokeColor": "rgba(220,220,220,0.8)",
              "highlightFill": "rgba(220,220,220,0.75)",
              "highlightStroke": "rgba(220,220,220,1)",
              "data": [7981, 9043, 11718, 8165, 8034]
          },
          {
              "label": "React classic",
              "fillColor": "rgba(151,187,205,0.5)",
              "strokeColor": "rgba(151,187,205,0.8)",
              "highlightFill": "rgba(151,187,205,0.75)",
              "highlightStroke": "rgba(151,187,205,1)",
              "data": [7172, 6904, 7421, 7592, 8030]
          },
          {
              "label": "ejs",
              "fillColor": "rgba(227,169,150,0.5)",
              "strokeColor": "rgba(227,169,150,0.8)",
              "highlightFill": "rgba(227,169,150,0.75)",
              "highlightStroke": "rgba(227,169,150,1)",
              "data": [17905, 17743, 16763, 19261, 17437]
          }
      ]
  }
}
</script><p>然后你可以在通过下面这个链接再对比一下ejs和node上其他一些模板引擎的性能，来了进行更详细的对比：<a href="http://paularmstrong.github.io/node-templates/benchmarks.html">Node Template Engine Benchmarks</a><label for="32" class="margin-toggle sidenote-number"></label><input type="checkbox" id="32" class="margin-toggle"/><span class="sidenote">如果这个结果对于其他情况也是有效的话，那或许我们可以认为React的性能超过了jade。当然我说的是“或许”。</span> 。</p>
<p>如果这个结果对于其他情况也是有效的话，那我个人认为React server render的性能已经够用了，甚至该说是足够优秀了。况且React远不止是模板引擎。</p>
<h2 id="-">结论</h2>
<p>相对于其他语言来说，Universal JavaScript恐怕是Node在web上所具有的最独特的特性，也是最值得去挖掘的。我们这里讨论了一些React在服务器上的使用及其潜力，也一笔带过了实际应用中存在的一些问题。更深入的内容就留待以后吧。</p>
<h2 id="-">相关链接</h2>
<p>StrongLoop的教程: <a href="https://strongloop.com/strongblog/node-js-react-isomorphic-javascript-why-it-matters/">How to Implement Node + React Isomorphic JavaScript &amp; Why it Matters</a></p>
<p><a href="https://github.com/erikras/react-redux-universal-hot-example">React Redux Universal Hot Example</a></p>
<p><a href="https://github.com/aickin/react-dom-stream">react-dom-stream</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages</link>
            <guid isPermaLink="false">4a736e05cbc84599b1fa7d72335115da</guid>
            <pubDate>Wed, 25 Nov 2015 16:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>