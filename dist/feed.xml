<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[oyyd]]></title>
        <description><![CDATA[oyyd]]></description>
        <link>https://blog.oyyd.net</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Wed, 16 Dec 2015 12:05:41 GMT</lastBuildDate>
        <atom:link href="https://blog.oyyd.netdist/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[探究用ES6 template strings替代前后端模板引擎]]></title>
            <description><![CDATA[<h1 id="-es6-template-strings-">探究用ES6 template strings替代前后端模板引擎</h1>
<p><strong>前言：</strong></p>
<p>JavaScript上有很多的模板引擎，不管是用于前端的、后端的、两者兼顾的，或是特性丰富的，或是在模板中尽可能减少逻辑的，选择十分丰富。如果你也曾在一个或大或小的项目中考虑如何选择模板引擎的话，那你肯定也和我一样犹豫过要怎么选择。</p>
<p>另一方面，在我大量使用React的工作时间中，我越发认可React中jsx的设计$sidenote(<a href="http://blog.vjeux.com/2013/javascript/jsx-e4x-the-good-parts.html">JSX: E4X The Good Parts</a>
)。而当我从React jsx的角度考虑一个好的模板引擎应该具有什么样的特性时，我意识到，对于比较简单的情形，使用ES6中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template strings</a>外加一些约定就已经足矣。你甚至不需要模板引擎就能够很好地处理绝大多数你以前需要用模板引擎来处理的工作。</p>
<p>那么下面就让我们来简单地探讨一下用ES6 template strings替代模板引擎的可行性及其优劣。</p>
<h2 id="-">一个简单的实例</h2>
<p>像是我的这个博客的一部分模板工作是直接利用template strings完成的（剩下的是React renderToString完成的）：</p>
<p>head标签的模板:</p>
<pre><code class="lang-js">// createHead.js
function createHead(ctx) {
  let {title, description} = ctx;

  return (
    `&lt;head&gt;
      &lt;title&gt;${title}&lt;/title&gt;
      &lt;meta name=&quot;description&quot; content=&quot;${description}&quot;/&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
      &lt;link rel=&quot;shortcut icon&quot; href=&quot;/static/favicon.ico&quot; /&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/codemirror.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/theme/monokai-sublime.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
    &lt;/head&gt;`
  );
}

export default createHead;
</code></pre>
<p>使用head标签模板，并引入每个页面的具体内容：</p>
<pre><code class="lang-js">// createPage.js
import createHead from &#39;./createHead&#39;;

function createPage(ctx) {
  let {title, description, content, initialState} = ctx;

  title = title || &#39;oyyd blog&#39;;
  description = description || &#39;这是亚东的博客，你可以在上面看到我的一些想法和实践，欢迎来访。&#39;;
  initialState = initialState || &#39;null&#39;;

  return (
    `&lt;!DOCTYPE html&gt;
    &lt;html&gt;
      ${createHead({title, description})}
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${content}&lt;/div&gt;
        &lt;script&gt;
          window.__INITIAL_STATE__ = JSON.parse(&quot;${initialState}&quot;);
        &lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/codemirror.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/javascript/javascript.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/xml/xml.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          (function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);

          ga(&#39;create&#39;, &#39;UA-70462946-1&#39;, &#39;auto&#39;);
          ga(&#39;send&#39;, &#39;pageview&#39;);
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
}

export default createPage;
</code></pre>
<p>这样，我们就在没有引入模板引擎的情况下，完成了这些简单的工作。</p>
<h2 id="-api-">对比实现其他模板引擎中的一些API与特性</h2>
<p>为了进一步探讨用template strings替代模板引擎的可行性，我们将对比实现其他模板引擎中的一些特性。</p>
<p>这里我们挑选的是<a href="http://mozilla.github.io/nunjucks/templating.html">nunjucks</a>中的一些特性，因其特性相对强大，更容易帮助我们说明template strings的特点及局限性。</p>
<p>另外，如果有些什么是template strings没有，而其他模板引擎做得到的话，你可以考虑用其他javascript的方式来实现，毕竟 <strong>你可以直接使用javascript这一强大的语言环境，通常再写一个函数/模板都能解决你的问题</strong>。并且相比于评价其好坏，你可能更需要去思考一下你是否真的需要这一特性。</p>
<h3 id="-">表达式</h3>
<p>nunjucks:</p>
<pre><code class="lang-html">{{ numItems*2 }}
</code></pre>
<p>template strings本身接受的就是表达式：</p>
<pre><code class="lang-js">`
${ numItems * 2 }
`
</code></pre>
<h3 id="if-else">if else</h3>
<p>nunjucks中的条件语句十分灵活：</p>
<pre><code class="lang-html">{% if hungry %}
  I am hungry
{% elif tired %}
  I am tired
{% else %}
  I am good!
{% endif %}
</code></pre>
<p>因为template strings只接受表达式的值，所以你最多只能用boolean-exp：</p>
<pre><code class="lang-js">`
${ hungry ? (
  I am hungry
) : (
  I am not hungry
) }
`
</code></pre>
<h3 id="for">for</h3>
<p>假设我们有：</p>
<pre><code class="lang-js">var points = [[0, 1, 2], [5, 6, 7], [12, 13, 14]];
</code></pre>
<p>在nunjucks中的：</p>
<pre><code class="lang-html">{% for x, y, z in points %}
  Point: {{ x }}, {{ y }}, {{ z }}
{% endfor %}
</code></pre>
<p>虽然template strings只接受表达式，但还是可以这样完成实现:</p>
<pre><code class="lang-js">`${points.map(point =&gt; (
  `Point: ${x}, ${y}, ${z}`
)).join(&#39;&#39;)}`
</code></pre>
<h3 id="-asynceach-asyncall">异步操作asyncEach与asyncAll</h3>
<p>nunjucks支持一些异步操作：</p>
<pre><code class="lang-html">&lt;h1&gt;Posts&lt;/h1&gt;
&lt;ul&gt;
{% asyncAll item in items %}
  &lt;li&gt;{{ item.id | lookup }}&lt;/li&gt;
{% endall %}
&lt;/ul&gt;
</code></pre>
<p>我们没办法直接在template strings中做这件事。但如果只是进行简单的异步操作的话，我们可以在外部进行处理，并且这和其他用javascript处理异步操作的情况一致：</p>
<pre><code class="lang-js">function renderPosts(posts) {
  return new Promise((resolve, reject) =&gt; {
    let content = &#39;&#39;;

    // 写些异步操作来修改content
    // ...

    resolve(`
      &lt;h1&gt;Posts&lt;/h1&gt;
      &lt;ul&gt;
        ${content}
      &lt;/ul&gt;
    `);
  });
}
</code></pre>
<p>但如果想要我们的模板整体支持异步的话，我们就需要写一些额外的代码来做这件事。而避免在你的模板中使用异步操作也是个选择。</p>
<h3 id="autoescaping">Autoescaping</h3>
<p>在nunjucks中，当<code>autoescape</code>选项被设置为<code>true</code>时，nunjucks会默认地转义变量的值，以防止可能来自用户的攻击。在使用template strings时，我们不难转义单个变量的值：</p>
<pre><code class="lang-js">var username = &#39;&lt;script&gt;&lt;/script&gt;&#39;;

function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

return `&lt;div&gt;{ escapeHTML(username) }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>而如果我们不想每次都手动调用转义函数，而是想要默认转义所有变量的值的话，我们可以利用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings">Tagged template strings</a>这一特性：</p>
<pre><code class="lang-js">function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${str}` : `${str}${escapeHTML(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`&lt;div&gt;{ uesrname }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>Tagged template strings这一特性很强大，你需要去充分利用它<label for="18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="18" class="margin-toggle"/><span class="sidenote">Tagged templates invite library designers to create powerful domain-specific languages. ——<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/">ES6 In Depth: Template strings</a></span> 。</p>
<h3 id="comments">comments</h3>
<p>在nunjucks中我们可以写注释：</p>
<pre><code class="lang-html">{# Loop through all the users #}
{% for user in users %}...{% endfor %}
</code></pre>
<p>并且模板中的注释在生成的字符串中会被自动截掉。如果我们想在template strings中写注释的话，我们就需要直接写成HTML的注释：</p>
<pre><code class="lang-js">`
&lt;!-- Loop through all the users --&gt;
`
</code></pre>
<p>那么我们能否在模板生成的字符串中自动截取掉这些注释呢？那我们还是要利用tagged template strings：</p>
<pre><code class="lang-js">function trimComments(str) {
  return str.replace(/&lt;!--.*?--&gt;/g, &#39;&#39;);
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${trimComments(str)}` : `${trimComments(str)}${trimComments(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`
  &lt;!-- Loop through all the users --&gt;
`;
</code></pre>
<h3 id="-">动态生成模板</h3>
<p>大部分模板引擎都可以动态生成模板，因为生成模板的过程实际上是在js上进行的一次编译过程，比如在nunjucks中：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;Hello {{ username }}&#39;;
var res = nunjucks.renderString(template, { username: username });
</code></pre>
<p>我们可以通过eval方法来动态生成模板：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;`Hello ${ username }`&#39;;
// 你应该需要更稳健的写法
var res = eval(template);
</code></pre>
<h2 id="-template-strings-">用template strings替代模板引擎的优点和缺点</h2>
<p>到目前位置，我们主要讨论了用template strings来替代模板引擎的可行性，下面我们会讨论这样做的优点和缺点。</p>
<p>模板引擎是<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>，其目的是拼接字符串。没有模板引擎我们当然也可以拼接字符串，只不过这一过程会很痛苦。而template strings本身就是为了解决这一问题而设计的，而tagged template strings又足够帮助我们实现模板引擎的功能<label for="19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="19" class="margin-toggle"/><span class="sidenote">利用tagged template strings开发DSL当然也是可行的，这里的讨论不涉及开发DSL的情况</span> 。</p>
<p>由于各种原因，通常模板引擎在处理很多问题时，通常会有自己的一套方法，比如说在一个模板中引入另一个模板你可能需要用import/require/partials语句，这实际上和JavaScript本身的import解决的是相似的问题。所以在使用template strings时，面对这些情况，我们就可以直接利用JavaScript中的特性来实现，而不需要像那样用一套新的东西来解决相似的问题。</p>
<p>这样很自然地，使用template strings替代模板引擎最主要的优点在于：</p>
<ol>
<li><p>贴近原生JavaScript，学习曲线更低。</p>
</li>
<li><p>你可以充分利用已有的JavaScript代码和特性，任何新的需求都可以通过你熟悉的JavaScript进行拓展。</p>
</li>
<li><p>你的模板部分的内容天然就是Universal JavaScript，你天然地就可以同时在浏览器上和服务器上使用模板相关的代码。</p>
</li>
</ol>
<p>但模板引擎毕竟是专门为处理模板而生的，有些用JavaScript实现比较麻烦的场景，用模板引擎的语法可能可以轻松地解决。实际上这里的讨论更像是在讨论使用DSL的优缺点。但使用template strings的理由在于 <strong>很多模板引擎上的很多特性都和JavaScript（ES6+）本身的特性重合了，我们没必要用一套新东西解决同样的问题</strong>。当然在ES6之前，JavaScript本身也没有模块，更别说考虑直接使用JavaScript中的特性来解决模板上的问题。</p>
<p>而另一个推荐使用template strings的原因在于Universal JavaScript。如果模板本身就是JavaScript代码的话，那么在前后端同时使用一份代码会变得容易得多。</p>
<p>另外不分离模板与代码的这一想主要是受到React的启发。React中的HTML(Virtual DOM, React DOM)部分和JavaScript代码紧密贴合<label for="20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="20" class="margin-toggle"/><span class="sidenote">这里主要是对比Angular和Polymer等框架，即主要由JavaScript代码控制HTML内容，而不是以HTML为主，也不是HTML和JavaScript平分秋色</span> 的想法，至少从实践角度上来说是很有效的，它使得代码十分容易维护。那么对于模板来说，不去刻意分离模板代码与普通的代码、模板代码既是JavaScript代码或许是个好的思路。</p>
<h2 id="-">生产环境上的应用</h2>
<p>在生产环境上单单使用template strings没办法解决我们的所有需求，而截止至本文时点我也没有看见过任何类似的实现。所以如果你觉得这是个好主意，你需要充分利用tagged template strings这一特性来组织起模板层。万幸的是这一过程不需要涉及编译，所以这会远比重新写一个模板引擎要简单得多。之后我也会尝试写一个帮助实现这一目的的库。</p>
<h2 id="-">其他相关链接</h2>
<p><a href="http://www.2ality.com/2015/01/template-strings-html.html">HTML templating with ES6 template strings</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/best_template_engine_in_node_js</link>
            <guid isPermaLink="false">e376e1b601f9fe30966dd8f5ca201e23</guid>
            <pubDate>Tue, 15 Dec 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究Webpack中的HMR(hot module replacement)]]></title>
            <description><![CDATA[<h1 id="-webpack-hmr-hot-module-replacement-">探究Webpack中的HMR(hot module replacement)</h1>
<p>2015年12月04日</p>
<p>什么是HMR？HMR能做什么？我们可以看看react-transform的演示：
<img src="/static/posts/webpack-hmr/react-transform-example.gif" alt="react-transform-example"></p>
<p>react-transform的实现是基于webpack-dev-server之上的，这里我将从webpack-dev-server和React两方面简单总结HMR的实现原理。</p>
<p>（<a href="https://github.com/oyyd/oyyd-blog/tree/master/research/react-hot-loader">从这里查看下文中的部分代码</a>）</p>
<h2 id="-webpack-dev-server-">从webpack-dev-server开始</h2>
<p>webpack不仅能够起到打包的作用，它还“附带了”一个专门用于开发的、由express构建的迷你服务器，即webpack-dev-server。webpack-dev-server的基本作用是处理我们的打包任务，并且它还会作为一个静态文件服务器提供我们最新打包成的静态文件供本地开发使用。webpack-dev-server与我们平时开发用的静态文件服务器的不同之处在于，它知道新的文件在何时被打包了出来，以及究竟是哪个文件发生了改变。</p>
<p>在“webpack-dev-server知道何时新文件会被打包出来的”这个基础之上，webpack-dev-server可以和浏览器之间建立一个web socket进行通信，一旦新文件被打包出来，webpack-dev-server就告诉浏览器这个消息，这时浏览器就可以自动刷新页面<label for="21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="21" class="margin-toggle"/><span class="sidenote">或是刷新iframe</span> ，而不用等到开发者手动刷新。</p>
<p><img src="/static/posts/webpack-hmr/hot-reload.gif" alt="complete-version"></p>
<p>对的，到这里webpack实际上已经实现了<a href="http://livereload.com/">livereload</a>的功能。</p>
<h2 id="-hmr-api">使用HMR的相关api</h2>
<p>webpack知道是哪个模块发生了改变，并且还提供了api帮助我们更新应用的状态。在这基础之上，只要我们知道要怎么用更新后的模块来更新我们的应用，我们就不需要刷新页面来重新加载整个应用了。</p>
<p>比如说我们需要使用一个模块A，这个模块A是个React Component，用来在页面上渲染<code>hello world</code>。对于这个简单的React Component来说，我们只需要在它更新以后重新渲染就能够保持应用的状态，而不需要其他工作。所以我们可以像下面这样做：</p>
<p>我们的SayHello.js文件：</p>
<pre><code class="lang-js">// SayHello.js
import React from &#39;react&#39;;

const color = &#39;black&#39;;

class SayHello extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div style={{color: color}}&gt;Hello, {this.props.name}!&lt;/div&gt;
    );
  }
}

export default SayHello;
</code></pre>
<p>我们的sayHelloEntry.js，</p>
<pre><code class="lang-js">// sayHelloEntry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import SayHello from &#39;./SayHello&#39;;

const name = &#39;world&#39;;

function renderComponent(RootComponent) {
  ReactDOM.render(
    &lt;RootComponent name={name}/&gt;,
    document.getElementById(&#39;main&#39;)
  );
}

// 通过module.hot获取webpack提供的一系列的api
if (module.hot) {
  module.hot.accept(); // 接受模块更新的事件，同时阻止这个事件继续冒泡
  renderComponent(SayHello); // 进行渲染
} else {
  // 非HMR状态下的代码
  renderComponent(SayHello);
}
</code></pre>
<p>在浏览器上加载这个页面后，我们就可以尝试修改sayHelloEntry.js模块中的<code>name</code>的值或是SayHello.js模块中的内容来查看结果：</p>
<p><img src="/static/posts/webpack-hmr/simple-version.gif" alt="complete-version"></p>
<p>虽然这个例子非常简单，但它也足以说明在webpack中的HMR的基本原理了。而你也应该很快注意到了，虽然在开发过程中，所有模块都有可能发生改变，但我们并不需要为每个模块写HMR代码。</p>
<p>那么当没有HMR相关代码的模块发生改变时，我们的应用到底是怎么运作的呢？这就是webpack HMR中的消息<label for="22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="22" class="margin-toggle"/><span class="sidenote">称为消息可能并不合适，但下文就这么用吧</span> 冒泡（bubble up）机制。</p>
<p><img src="/static/posts/webpack-hmr/bubble-up.png" alt="bubble-up"></p>
<p>当一个模块C发生改变，而模块内又没有HMR代码来处理这一消息时，那这一消息就会被传递到依赖模块C的其他模块上；如果消息在新模块上没有被捕获的话就会再次进行传递；如果所有的消息都被捕获了的话，那我们的应用就应该已经按照代码进行了更新；反之如果有消息冒泡到了入口(entry)文件还没有被捕获的话，那就说明我们的代码中没有处理这类变更方法，那webpack就会刷新浏览器页面，即从HMR回退到LiveReload。</p>
<h2 id="-react-hmr">在React上实现HMR</h2>
<p>实现HMR时最复杂的地方是在应用层面上。现在在让我们看看如何在React上实现HMR。</p>
<p>虽然在上面的例子中，我们的SayHello.js就是React组件，但这里我实际上避开了在React上应用HMR时最困难的一点：我们应用的state。</p>
<p>如果我们把上面例子中的SayHello.js替换成一个计数器（Counter.js）的话：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }

  plusOne() {
    this.setState({
      count: this.state.count + this.props.valueAddEachClick * 2,
    });
  }

  render() {
    const valueAddEachClick = this.props.valueAddEachClick * 2;
    return (
      &lt;div&gt;
        &lt;label&gt;Value: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.plusOne.bind(this)}&gt;+{valueAddEachClick}&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>虽然HMR依然有效，但每次模块更新后，你会发现Counter的当前计数又会回到初始状态。因为在这一过程中，React组件中的state丢失了。</p>
<p>state丢失的原因和React的diff算法<label for="23" class="margin-toggle sidenote-number"></label><input type="checkbox" id="23" class="margin-toggle"/><span class="sidenote">关于React的diff算法，推荐看@vjeux的这篇<a href="http://calendar.perfplanet.com/2013/diff/">React’s diff algorithm</a></span> 有关。简单来说就是React在判断如何更新应用时，如果发现两个React Element类型不同的话，则会直接用新的React Element替换旧的React Element。</p>
<p>像我们在HMR的过程中更新了Counter.js模块，会重新生成新的Counter，实际上新的Counter和旧的Counter不是同一个Counter，即它们是不全等的。</p>
<p>所以在当前React没有提供任何相关api的状况下，如果我们仍想要保留原来的state的话，那我们就不能用新的组件直接替换旧的组件，即我们要保留原来组件的外壳，并更新其上的所有方法（利用mutable data）。同时因为数据没有发生变化，所以我们还需要某种方式来强制命令React更新应用的状态。</p>
<p>而这事实上就是react-proxy和react-deep-force-update的作用了。这两个库同样也是react-hot-loader和react-transform的依赖。由于这两个库的实现本身相对复杂费解，同时跟React内部的一些机制紧密相连，所以这里便不再深入了。</p>
<p>我们可以利用这两个库来完成帮助我们保留Counter的state：</p>
<pre><code class="lang-js">//entry.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

import Counter from &#39;./Counter&#39;;
import createProxy from &#39;react-proxy&#39;;
import deepForceUpdate from &#39;react-deep-force-update&#39;;

if (module.hot) {
  // module.hot.data是个{}，我们用它来在旧模块和新模块之间传递数据
  module.hot.data = module.hot.data || {};
  let {proxy, rootInstance} = module.hot.data;

  if (!proxy) {
    proxy = createProxy(Counter);
    const Component = proxy.get();

    rootInstance = ReactDOM.render(
      &lt;Component initialCount={10} valueAddEachClick={2}/&gt;,
      document.getElementById(&#39;main&#39;)
    );
  } else {
    proxy.update(Counter);
    deepForceUpdate(rootInstance);
  }

  module.hot.accept();

  module.hot.dispose(function(data) {
    // dispose方法用来定义一个一次性的函数，
    // 这个函数会在当前模块被更新之前调用。所以
    // 我们在这里，也就是proxy变量被销毁之前储存它。
    data.proxy = proxy;
    data.rootInstance = rootInstance;
  });
}
</code></pre>
<p>至此我们的代码也就小有所成了。</p>
<p><img src="/static/posts/webpack-hmr/complete-version.gif" alt="complete-version"></p>
<p>总结：</p>
<p>HMR很有意思，虽然它看起来象是个玩具一样，但事实上它确实能够提高我们的开发效率，因为它缩短了我们初始化应用及手动恢复应用状态的时间。特别是对web前端这样，UI代码占很重一部分工作，随时需要查看应用样式的编程任务来说，这点更为重要。</p>
<p>但现在要应用HMR，限制很多。不过本文截至时，@gaearon已经成了facebook的一员了，或许之后还能期待一下React在开发环境上为我们提供更多的可能性也说不定。</p>
]]></description>
            <link>https://blog.oyyd.net/post/how_does_react_hot_loader_works</link>
            <guid isPermaLink="false">632bf391d8f8f9e2d0678d8da613d395</guid>
            <pubDate>Thu, 03 Dec 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ Universal(Isomorphic) JavaScript在React上的应用]]></title>
            <description><![CDATA[<h1 id="universal-isomorphic-javascript-react-">Universal(Isomorphic) JavaScript在React上的应用</h1>
<p>2015年11月26日</p>
<p>React中的renderToString方法允许我们在服务器上渲染React部件，这点不仅可以帮助我们解决一些会出现在单页应用(SPA)上的问题，它甚至还允许我们将React用作模板引擎（template engine）来使用。下文还将附带一个简单的benchmark来对比React与传统模板引擎之间性能。</p>
<h2 id="-universal-javascript-">什么是Universal Javascript？</h2>
<p>Universal Javascript又称Isomorphic JavaScript<label for="24" class="margin-toggle sidenote-number"></label><input type="checkbox" id="24" class="margin-toggle"/><span class="sidenote"><a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9">两个名称的来由</a></span> ，是指可以运行在客户端和服务器上的javascript代码。<label for="25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="25" class="margin-toggle"/><span class="sidenote"><a href="http://isomorphic.net/">http://isomorphic.net</a></span> </p>
<p>实现Universal Javascript的原理并不复杂，我们只需要在代码中获取当前运行环境（浏览器还是服务器？），并根据环境作出不同响应即可。比如在<a href="https://www.meteor.com/">Meteor</a>中，你会看到这样的代码出现在同一个文件中：</p>
<pre><code class="lang-js">if (Meteor.isServer) {
  // This code only runs on the server
}

if (Meteor.isClient) {
  // This code only runs on the client
}
</code></pre>
<p>只要通过<code>Meteor.isServer</code>和<code>Meteor.isClient</code>，我们就能够控制代码在不同环境下的逻辑，从而使得这份代码可以同时在客户端和服务器上执行，并根据环境返回对应的结果。</p>
<h2 id="universal-javascript-react-">Universal JavaScript可以给React应用带来什么？</h2>
<p>那么对于React来讲，Universal Javascript又有什么用呢?我们知道，html标签加载了一部分就会显示一部分； 而React是通过javascript来渲染html内容的。这也就意味着在完成脚本的加载和运行之前，React应用中的html内容是不会出现在页面上的。</p>
<p>像是本站blog.oyyd.net原来是用React + React Router写的SPA(单页)应用，页面内容是这样的：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;oyyd blog - 这是亚东的博客（偏技术），你可以在上面看到我的一些想法和实践，欢迎来访。&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;meta name=&quot;description=&quot; content=&quot;内容偏前端，但不局限于前端，没准你会感兴趣。&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以看到代码中基本没有与内容相关的html标签，这就导致SPA一直存在的一些<strong>问题</strong>：</p>
<ol>
<li><p>用户在脚本加载运行之前是不会看到React部分的内容，从体验上来讲好像等待了更多的时间（特别是在网速差的时候）。</p>
</li>
<li><p>如果javascrript加载失败或是运行时产生错误的话（或是浏览器直接禁用了javascript的话），用户看不到任何内容。</p>
</li>
<li><p>搜索引擎无法有效地爬取页面内容<label for="26" class="margin-toggle sidenote-number"></label><input type="checkbox" id="26" class="margin-toggle"/><span class="sidenote">对于google而言，有一些<a href="https://developers.google.com/webmasters/ajax-crawling/docs/getting-started">解决办法</a>来引导爬虫去另一个事先准备好页面内容的地方</span> ，难以进行SEO。</p>
</li>
</ol>
<p>对于这些问题，我们可以利用Universal JavaScript，也即React中的<code>renderToString</code>方法，在服务器上就渲染出React应用中的部分内容返回给浏览器，从而解决这些问题。</p>
<h2 id="-">实现</h2>
<p>现在的blog.oyyd.net就充分利用了React中的<code>renderToString</code>。你可以在浏览器中查看源码来查看这个网站现在的状况。接下来还是让我们通过一个更加简洁的例子来了解这一流程：</p>
<blockquote>
<p>注意：下面的代码并不完备，由于构建过程相对繁杂多样，所以这些代码更多是为了让我们能更好地关注这一流程中的重点步骤。</p>
</blockquote>
<p>假设我们要实现一个简单的计数器，这个计数器的初始值会在服务器端就设置好。</p>
<p>整个流程大致如下：</p>
<ol>
<li><p>请求到来，服务器初始化我们的React计数器，并将其渲染成字符串。</p>
</li>
<li><p>把React生成的字符串和计数器的初始值放到模板中，合并成完整的HTML内容返回给浏览器。</p>
</li>
<li><p>在浏览器上，利用计数器的初始值初始化React应用。</p>
</li>
</ol>
<p>其中我们的React计数器代码如下：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props){
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }
  countPlusOne(){
    this.setState({
      count: this.state.count + 1,
    });
  }
  render(){
    return (
      &lt;div&gt;
        &lt;label&gt;数值: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.countPlusOne.bind(this)}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Counter;
</code></pre>
<p>当请求来临时，express根据参数设置初始状态生成一个Counter的ReactElement,并将其渲染成字符串：</p>
<pre><code class="lang-js">// server.js
import fs from &#39;fs&#39;;
import express from &#39;express&#39;;
import React from &#39;react&#39;;
import {renderToString} from &#39;react-dom/server&#39;;

import Counter from &#39;./components/Counter&#39;;

const app = express();
app.get(&#39;/:initialCount&#39;, (req, res) =&gt; {
  const {initialCount} = req.params;

  // 生成Counter实例的字符串
  const counterString = renderToString(
    &lt;Counter initialCount={initialCount}/&gt;
  );

  // 注意下面不仅将Counter的字符串放入了html内容中，并且
  // 还将参数保存在了全局浏览器上的全局变量`__INITIAL_COUNT__`
  req.send(
    `&lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${counterString}&lt;/div&gt;
        &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          window.__INITIAL_COUNT__ = ${initialCount};
        &lt;/script&gt;
        &lt;script src=&quot;/bootstrap.js&quot;&gt;&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
});

app.listen(8080);
</code></pre>
<p>当浏览器上的请求从服务器上返回时，bootstrap.js脚本被加载运行，在浏览器上初始化完整的React应用：</p>
<pre><code class="lang-js">// bootstrap.js
React.render(
  &lt;Counter initialCount={window.__INITIAL_COUNT__}/&gt;,
  document.getElementById(&#39;main&#39;)
);
</code></pre>
<p>到这里，我们的计数器应用就顺利地加载在了浏览器上，并且这一次，我们的页面一开始不会像SPA应用那样空空如也。</p>
<p>这一过程就像是我们的React应用的初始化过程被分成了两次进行。先是在服务器上，我们初始化了React应用中的HTML的内容，并发送到前端；然后浏览器接过了这些内容，继续进行DOM事件绑定等工作。而值得注意的是，为了能在前端以正确的初始状态启动应用，我们需要把我们应用的状态（上面例子中的<code>window.__INITIAL_COUNT__</code>）也一并传过去，用于初始化。</p>
<h2 id="-react-">事实上，我们在用React替代服务器端的模板引擎</h2>
<p>如果你回想一下这一过程，你可能会注意到在这一流程中，React承担起了服务器上本应由模板引擎处理的(template engine)大部分工作<label for="27" class="margin-toggle sidenote-number"></label><input type="checkbox" id="27" class="margin-toggle"/><span class="sidenote"><del>现在的React是无法生成<code>html</code>, <code>script</code>等标签的</del>很惭愧，事实上是可以的。</span> 。</p>
<p>如果你写过服务器端模板，同时也很熟悉React，那你可能会和我有同样的感受：React中的模板（或者说是jsx）用起来甚至比专业的模板引擎更加顺手。因为使用模板引擎意味着你在用一门模板语言和javascript交互；而React本身就是javascript，jsx本质也是javascript，所以React中的“模板”用起来要自然得多。</p>
<p>如果你只需要静态页面的话，你完全可以写一些没有state的React部件来承担服务器上模板引擎的大部分工作。事实上现在已经有<a href="https://github.com/reactjs/express-react-views">express-react-views</a>这样的库来实现这一目的<label for="28" class="margin-toggle sidenote-number"></label><input type="checkbox" id="28" class="margin-toggle"/><span class="sidenote">其作者也是React的维护者<a href="https://github.com/zpao">@zpao</a></span> 。</p>
<p>那么让一门前端框架作为模板引擎是不是多余之举呢？</p>
<p>事实可能完全相反。因为浏览器上js所使用的模板和服务器上渲染的模板原本就应该是同一份模板，它们同属于我们浏览器上的应用。只不过由于种种原因，我们一直不得不将其拆分成两部分。那么现在如果服务器的这份模板由本身就主要用于浏览器上的React来生成的话，我觉得是再合理不过的了。</p>
<p><img src="/static/posts/react-server-render/react-as-template-engine.png" alt="React as Template Engine"></p>
<p><del>当然因为React无法生成所有常用的标签，所以你可能还是需要模板引擎来帮你处理React应用之外的工作。</del>一般我们用在浏览器上的React应用不会用到诸如：html，script，body这样的标签，但我们可以在服务器渲染时使用他们来生成完整的内容。</p>
<p>并且这样做，我们可以充分利用同一份代码，技术栈也会变得更加简单。想象一下，没有html、template、ejs、jade等文件，你的js文件就是你的模板文件，你可以直接利用js上的模块等特性，这能够省多少事！</p>
<p>但是如果你把之前用于浏览器上的React部件直接拿来服务器渲染的话，你可能没办法如愿。举个例子：在浏览器上你很可能在会直接使用全局变量window，但在node上这会抛出错误。你需要在写你的应用的时候就考虑清楚一个部件在服务器上渲染时的情况。</p>
<p>而你的React部件拥有state的话，你是没办法直接控制他们的状态的。但如果你使用<a href="https://github.com/rackt/redux">Redux</a>来将部件中的state移动到外部的话，你就可以通过Redux来从外部自由控制你部件的状态，也就可以控制服务器端渲染的内容了。</p>
<h2 id="-benchmark">一个简单的benchmark</h2>
<p>React不是纯粹的模板引擎，那么与node上其他的模板引擎相比，它的server render的性能会不会差很多呢？这里我们将前面的计数器代码做一下改动，通过一个小范围的、非常简单的benchmark来对比React和ejs之间性能的量级：</p>
<blockquote>
<p>这里还是要再次强调：这个benchmark的目的只是在于帮助我们了解他们之间大概的性能，实际应用时的状况很可能不是这样的。</p>
</blockquote>
<p>设备：Windows 8.1 Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz 2.59GHz  8.00GB</p>
<p>版本：React 14.0.2，ejs 2.3.4</p>
<p>ejs使用的模板文件：</p>
<pre><code class="lang-html">&lt;div&gt;
  &lt;label&gt;数值:&lt;%=count%&gt;&lt;/label&gt;
  &lt;button&gt;+1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>React Counter(es6中类的形式)<label for="29" class="margin-toggle sidenote-number"></label><input type="checkbox" id="29" class="margin-toggle"/><span class="sidenote">下面的代码都使用了babel进行转换，可能对结果会产生一些影响</span> ：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>React Counter(传统方式)：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

const Counter = React.createClass({
  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  },
});

export default Counter;
</code></pre>
<p>测试时的渲染语句：</p>
<pre><code class="lang-js">// React
renderToString(&lt;Counter count={10}/&gt;);

// ejs
ejs.render(template, {
  count: 10,
});
</code></pre>
<p>设置node环境为<code>production</code>，避免React做一些用于开发环境的工作，并开始渲染：</p>
<pre><code>NODE_ENV=production node lib/index.js
</code></pre><p>结果如下：</p>
<p>数值单位是ope/sec（每秒渲染数）越高越好</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>第1次</th>
<th>第2次</th>
<th>第3次</th>
<th>第4次</th>
<th>第5次</th>
</tr>
</thead>
<tbody>
<tr>
<td>React ES6 class</td>
<td>7981</td>
<td>9043</td>
<td>11718</td>
<td>8165</td>
<td>8034</td>
</tr>
<tr>
<td>React classic</td>
<td>7172</td>
<td>6904</td>
<td>7421</td>
<td>7592</td>
<td>8030</td>
</tr>
<tr>
<td>ejs</td>
<td>17905</td>
<td>17743</td>
<td>16763</td>
<td>19261</td>
<td>17437</td>
</tr>
</tbody>
</table>
<p>然后你可以在通过下面这个链接再对比一下ejs和node上其他一些模板引擎的性能，来了进行更详细的对比：<a href="http://paularmstrong.github.io/node-templates/benchmarks.html">Node Template Engine Benchmarks</a><label for="30" class="margin-toggle sidenote-number"></label><input type="checkbox" id="30" class="margin-toggle"/><span class="sidenote">如果这个结果对于其他情况也是有效的话，那或许我们可以认为React的性能超过了jade。当然我说的是“或许”。</span> 。</p>
<p>如果这个结果对于其他情况也是有效的话，那我个人认为React server render的性能已经够用了，甚至该说是足够优秀了。况且React远不止是模板引擎。</p>
<h2 id="-">结论</h2>
<p>相对于其他语言来说，Universal JavaScript恐怕是Node在web上所具有的最独特的特性，也是最值得去挖掘的。我们这里讨论了一些React在服务器上的使用及其潜力，也一笔带过了实际应用中存在的一些问题。更深入的内容就留待以后吧。</p>
<h2 id="-">相关链接</h2>
<p>StrongLoop的教程: <a href="https://strongloop.com/strongblog/node-js-react-isomorphic-javascript-why-it-matters/">How to Implement Node + React Isomorphic JavaScript &amp; Why it Matters</a></p>
<p><a href="https://github.com/erikras/react-redux-universal-hot-example">React Redux Universal Hot Example</a></p>
<p><a href="https://github.com/aickin/react-dom-stream">react-dom-stream</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages</link>
            <guid isPermaLink="false">4a736e05cbc84599b1fa7d72335115da</guid>
            <pubDate>Wed, 25 Nov 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ Javascript中的不可变（immutable）数据结构]]></title>
            <description><![CDATA[<h1 id="javascript-immutable-">Javascript中的不可变（immutable）数据结构</h1>
<p>2015年10月6日</p>
<p><strong>前言</strong></p>
<p><a href="http://jlongster.com/Using-Immutable-Data-Structures-in-JavaScript">James Long</a>
的这篇文章对在javascript中使用
不可变数据结构的情况进行了阐述，看完之后我发现里面的不少
话都说到我的心坎里去了。这里我会阐述一些我对此的一些的想法，
并尝试总结一下文中的部分想法，做一个简单的
总结（尽可能在十数分钟的阅读内了解内容并对此留下一个较为深刻印象）。</p>
<p>下文将“不可变的数据结构”简称为“immutable”，将leebyron写的库immutable称为“immutablejs”。</p>
<h2 id="-immutable-">什么是immutable?</h2>
<p>引用immutablejs文档上的话，并夹杂一些我自己的解释，
即“一旦创建后便不可再发生改变的数据结构”，
“因为原来的数据一旦创建创建后便不可发生
改变，<strong>所以当你进行改变数据的操作时，实际上是替换掉原来的整个数据</strong>
（因为你不能改变原来数据中的某一部分）。并且这种做法会
带来各种好处”。</p>
<p>再让我们来看一下immutablejs文档上的例子：</p>
<pre><code class="lang-js">var Immutable = require(&#39;immutable&#39;);
// map1是一个Map结构的数据
var map1 = Immutable.Map({a:1, b:2, c:3});
// 把map2赋值成一个“改变过的”map1
var map2 = map1.set(&#39;b&#39;, 50);
// 结果是map1仍旧是map1，它不会发生改变，
// 而map2变成了“改变后的map1”
map1.get(&#39;b&#39;); // 2
map2.get(&#39;b&#39;); // 50
// 并且 map1 !== map2。后面的例子也会利用到这一点
</code></pre>
<p>代码中的注释更确切地说应该是“map1所引用的数据对象
不会发生改变”，因为你仍旧可以改变
map1变量所指向的数据。immutable不同于<code>const</code>。</p>
<h2 id="-immutable-">为什么需要immutable？</h2>
<h3 id="1-immutable-">1.Immutable可以简化我们对数据的使用</h3>
<p>当你在使用React（flux）或是Angular等框架时，你会绑定视图和你的
数据，好让视图跟随数据发生改变。如果数据没有发生变化，
那我们也就不需要重新渲染视图，否则会浪费性能。</p>
<p>一个最清晰的例子便是React的class中的<code>shouldComponentUpdate</code>方法。
每次尝试改变数据后，React都会带着新数据调用这一方法。只要我们在这个方法中返回false，
那React就不会重新进行渲染。</p>
<p>那么问题在于：在我们决定要不要重新渲染数据时，
我们怎么知道我们的数据到底有没有发生变化？</p>
<p>如果我们需要比对的数据是Number, String, Boolean这样
的简单数据类型的话，我们很容易通过全等来判断数据
是否发生变化：</p>
<pre><code class="lang-js">var state = true;
var newState = false;
if (state !== newState){
  // 重新渲染视图的代码
}
</code></pre>
<p>但如果你的数据是原生可变的Object（或Array）,
像下面这样的情况：</p>
<pre><code class="lang-js">var state = {count: 0};
var newState = {count: 0};
if (state !== newState){
  // 因为`state`和`newState`的引用是不同的，所以
  // 重新渲染视图的代码一定会执行
}
// 或是
var state = {count: 0};
var newState = state;
newState.count = 1;
if (state !== newState) {
  // 因为`state`和`newState`的引用是相同的，所以
  // 重新渲染视图的代码一定不会执行  
}
</code></pre>
<p>你就没办法通过全等来判断数据是否发生了
改变。你需要遍历这个对象上的属性（或数组中的元素）
来判断是否发生了改变（注意下面的例子并不完备）：</p>
<pre><code class="lang-js">var state = {count: 0};
var newState = {count: 0};
var isDataChanged = false;
for(var key in newState){
  if(newState.hasOwnProperty(key)
    &amp;&amp; newState[key] !== state[key]){
      isDataChanged = true;
      break;
    }
}

if (isDataChanged){
  // 执行重新渲染视图的代码
}
</code></pre>
<p>对于上面这个例子，如果对象的属性（或是数组的
元素）也是可变的数据类型的话，那你就需要递归地
检验每一个属性（元素）及其子属性（元素）。
这一操作的复杂程度和其消耗可想而知。</p>
<p>但如果你使用了immutablejs中的数据结构，你就可以很轻松的达成这一目的：</p>
<pre><code class="lang-js">var Immutable = require(&#39;immutable&#39;);
var state = Immutable.Map({count: 0});
var newState = state.set(&#39;count&#39;, 1);
if (state !== newState){
  // 重新渲染视图
}
</code></pre>
<h3 id="2-immutable-">2.使用immutable性能更好</h3>
<p>同上文所述，如果我们能够快速有效的判断数据是否发生了变化，从而避免不必要的渲染，那我们
的App就会有更好的性能。并且像是immutablejs这样的库
一般在实现细节上都会更加优秀，以让变动数据的操作本身有更好的性能
<label for="31" class="margin-toggle sidenote-number"></label><input type="checkbox" id="31" class="margin-toggle"/><span class="sidenote">下面这段引用摘自James的原文</span> ：</p>
<blockquote>
<p>...it implements fully persistent data structures from scratch using advanced things like tries to implement structural sharing. All updates return new values, but internally structures are shared to drastically reduce memory usage （and GC thrashing).</p>
</blockquote>
<h3 id="3-immutable-mutable">3.从函数式编程的角度来讲，immutable优于mutable</h3>
<p>因为immutable不会背地里改变数据。</p>
<h2 id="-immutable-">不使用immutable的理由</h2>
<p>在实现immutabl(或达到相同目的)的库中:</p>
<p>无疑<a href="https://facebook.github.io/immutable-js/">immutablejs</a>是该类项目中最流行的。</p>
<p>而<a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>则轻量得多，
但它在使用上更接近原生的javascript数据结构。</p>
<p>使用React的项目则可以直接利用<a href="https://facebook.github.io/react/docs/update.html">immutability-helpers</a>
来达到类似的效果。</p>
<p>使用immutable有种种的好处，但至少直到现在为止，它
在使用javascript的生产环境中，似乎也还没有很流行。<strong>究其原因，一是现在大部分的web app规模相对较小，
不能很好体现出immutable的优势；再者便是使用像immutablejs这样非轻量级的库会增加程序的复杂程度，
因为其数据结构及使用方法与javascript中原生的数据结构相差甚远</strong>。</p>
<p>对于我自己的体会来说，我们在公司里用React+Redux重构了原来的大部分代码，并开发新功能。
而在这一过程中我们没有加入immutablejs，即便Redux使用全等来判断是否要重新渲染，强制要求使用
符合immutable特点的数据结构。
其原因完全同前面所述。单从主观感觉上来讲，引入immutablejs比引入React给程序员带来的负担要更大，
而且使用immutablejs还要面对绝大多数不使用immutablejs的第三方的问题，你可能要写大量的代码
来在immutable和mutable类型的数据结构之间进行转换。</p>
<p>所以我们最后只使用了React自带addons中的immutability-helpers来实现这一目的，虽然这一小工具
从数据结构本身并不会给我们带来性能提升，但它帮助我们少写了很多代码，而React也能够利用全等来
简单地判断数据是否发生了改变。</p>
<h2 id="-">结论</h2>
<p>immutable可以简化数据操作上的一些问题，提高应用的性能。但我们更需要根据实际情况来考虑
其带来的副作用，根据情况做出选择。</p>
]]></description>
            <link>https://blog.oyyd.net/post/immutable_data_structure_in_javascript</link>
            <guid isPermaLink="false">fd6bc6dad2cf0e938d67908a4f3fd2af</guid>
            <pubDate>Mon, 05 Oct 2015 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[ 为什么我选择了React来重构我们的前端]]></title>
            <description><![CDATA[<h1 id="-react-">为什么我选择了React来重构我们的前端</h1>
<p>2015年8月28日</p>
<p><strong>前言：</strong></p>
<p>很早以前，我曾经写过自己对React的看法，但那时候自己基本是囫囵吞枣，
只是去看了React最明显的那些特性，完全没有去尝试深入理解其中的设计思想。
其结果便是我完全没有理解到React的优点。直到最近，我们公司和其他大多数初创
公司一样，需要真正地正视前端开发中的问题，并开始进行重构。这时我不得不
从我熟悉的Angular和另一个不少大牛极力推荐的框架——React中作出选择。
于是在仔细思考我们开发中的问题，并结合了他人的看法之后，我选择了React。</p>
<p>这里特别推荐<a href="http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome">James Long的这篇关于React的文章</a>。</p>
<p>当然首先让我们从稍远一点的话题开始。</p>
<h2 id="-jquery-">只用原生（或jQuery）开发时遇到的问题</h2>
<h3 id="-">原生开发缺少统一的抽象方法</h3>
<p>当一个项目刚刚开始时，用原生js进行开发一般不会遇到特别严重的问题。但当
项目进行了一段时间以后，我们多半会发现我们需要想办法来帮我们管理一团糟
的代码。</p>
<p>我们可以看看当我们尝试去修改一个功能或修复一个bug时的一般性做法：</p>
<ol>
<li><p>寻找DOM（在浏览器审查元素）</p>
</li>
<li><p>看一下这个DOM上比较像钩子的属性（<code>id</code>, <code>class</code>, <code>role</code>, <code>data-xxx</code>）</p>
</li>
<li><p>搜索代码中用了这个钩子的地方（基本上通过文本搜索找<code>$()</code>）</p>
</li>
<li><p>若命中则进入下一个地方，否则从1, 2, 3中的某一步重新开始，直到命中。</p>
</li>
</ol>
<p>而即便你找到了要修改代码，如果你没有遍历上述流程中每一种可能的情况的话，你就很难保证你没有
遗漏其他情况。特别是在修改他人的代码时，你很难保证自己做出的修改是完整的、没有副作
用的。</p>
<p>产生这一问题的原因，我认为是我们的代码缺少有效的抽象方法。原生（和jQuery）中的api
都是用来完成某种特定的功能，但并不能帮助我们写出更容易预测，更容易维护、扩展的代码。
<strong>这就导致了在阅读、维护较为复杂的代码时，虽然能很明确每一个小操作的作用，但自顶至底来看，
却很难明确每一个操作的目的。</strong> 你很难看懂别人的代码或是自己以前的代码。</p>
<p>虽然我们平时也会用某些方式（面向对象，jQuery plugin，或一些更简单细碎的方式）
来帮助我们实现目的，但这大多都是我们为我们当前面临的问题临时想出来的办法。
这样的抽象是混乱的、不统一的，对于别人来说也不一定能够理解。</p>
<p>除了缺少抽象导致的代码难以理解、修改以外，另一个不良后果便是很难确定代码的作用范围，
很难复用代码。而ES5及以前的javascript缺少原生模块机制也是造成这一后果的重要原因。</p>
<h3 id="-dom-dom-">需要人工DOM操作来维护DOM树的状态</h3>
<p>看一眼我们的jQuery代码（或原生），不难发现我们绝大多数时候都是在“query DOM”（$(),或是getElement...）。
因为我们需要找出目标DOM，然后改变目标DOM。</p>
<p>这是因为在应用中DOM树的状态和javascript（中的数据）的状态是分离的，
而我们修改目标DOM的目的实际上是要维护维护DOM树和javascript
状态的一致。</p>
<p>维护这两者一致的工作本身是不可避免的，但问题是在代码量变大、代码变复杂的情况下，
人工维护的代价可能要比我们想象的要复杂的多<label for="32" class="margin-toggle sidenote-number"></label><input type="checkbox" id="32" class="margin-toggle"/><span class="sidenote"><a href="http://www.csdn.net/article/2013-04-12/2814864-Localytics-AngularJS-Backbone">Localytics公司在backbone的实践中明确提出了这一点</a></span> 。因为代码运行的某一时刻中，虽然你目标的DOM状态
是确定的，但当前DOM树的状态却可能是多种多样的（不确定的）。理论上要把DOM树改变成目标状态的话，
你的代码就需要考虑当前DOM树各种可能的状态。不仅如此，你的代码还需要包含改变DOM树状态
的一步步的操作。</p>
<h2 id="-react-">对于这些问题，React做了什么？</h2>
<h3 id="-">树状结构的应用与声明式的代码</h3>
<p>React要求每一个ReactClass的渲染方法中，都有且只有一个最外层的Virtual DOM，但它内部
（children属性）可以包含多个Virtual DOM。所以用React写的应用的结构是树状的。
React应用的树状结构使得任何一个ReactClass都只和它的外层ReactClass以及
子ReactClass进行直接交互，也即我们很容易弄清楚我们某一部分代码的作用范围。
不仅如此你只要从<code>render</code>方法中就可以得知你代码使用到的其他部件所用到的当前部件的
属性、方法，这就使得我们在修改React的代码时会格外轻松。</p>
<p>实际上这一点对于涉及到UI的代码来说是十分重要的，
因为我个人觉得通常在产品需求变化时，UI的变化经常会需要你不断地考虑是否要对代码做
抽象，分离出一部分公用的内容。而React会让你的每一部分代码都为复用做好准备。</p>
<h3 id="-virtual-dom-dom-">直接生成Virtual DOM来取代DOM操作</h3>
<p>我们写的React代码并不直接操作DOM，而是根据当前的数据组织出一个Virtual DOM，然后由
Virtual DOM完成对DOM树的调节。</p>
<p>由于新生成的Virtual DOM会和上一次的Virtual DOM进行比对，
然后根据Virtual DOM之间的差别对DOM树进行最小的、必要的调节，所以这一做法在大多数
情况下都能够保证性能。</p>
<p>而组织Virtual DOM来操作DOM的更大好处在于：你不需要
考虑将DOM树从当前的状态A变成目标状态B所需要进行的每一个DOM操作，而只要根据当前数据的
状态去组织一个目标状态B的Virtual DOM即可，所以这种做法节省了我们的很多工作。并且你的
应用越是复杂，Virtual DOM这种做法的优势便越是明显。</p>
<p>另外值得一提的是，组织Virtual DOM的过程完全可以被当成是模板引擎的一种实现。
并且与其他模板做对比时，我发现Virtual DOM + jsx异常灵活。</p>
<h3 id="-">容易确定的数据流</h3>
<p>大多数情况下，我们都可以通过改变应用中的数据来改变React应用的状态。很多时候我们在追踪
应用的状态时，实际上都是在追踪数据的变化。所以掌握数据的状态在维护及扩展时是非常重要的。
得益于前面所述的树状结构以及数据和视图的紧密贴合，React应用的数据流向十分清晰明。</p>
<p>除了这点，React应用中的每一部分都使用props和states两个属性来储存状态。
其中props属性是外部传入的，在ReactElement部不（应该）发生改变；
而state属性产生于ReactElement的内部，可传递到子ReactElement中作为props。
这两个属性很好地将控制components状态的数据进行了分类，让我们更容易在局部代码中对数据进行朔源。</p>
<h2 id="-angular-">我没有选择Angular的原因</h2>
<p>React和Angular之间过于不同，以至于我把这篇文章的初衷都稍作了修改。
所以这里更多从实践的角度谈谈我的看法，可能充满了个人偏见。</p>
<h3 id="1-react-">1. React的代码可预测行更强</h3>
<p>把这个问题放到React，你会发现数据都放在props（外部传入）和state（本身拥有）上，
部件在每个生命周期上要做的事情都有序地放置在componentWillMount、componentDidMount、
componentDidUpdate等等的方法中（当然你不一定需要全都用到），涉及Virtual DOM的东西都在Render方法里，
少量退回到原生（jquery）的DOM操作都可以通过refs属性找到。
这样，当你们从React的角度来思考一个需求的实现时，你和你同事的思路一般不会相差太大。</p>
<p>说这是个问题，是因为我觉得适合生产环境上的框架应该单靠框架本身就能使团队中的每个人都对某一个功能的开发抱有相近的想法。
这样代码就更容易预测。</p>
<h3 id="2-mvc-view-sidenote-react-view-">2. MVC与View<label for="33" class="margin-toggle sidenote-number"></label><input type="checkbox" id="33" class="margin-toggle"/><span class="sidenote">React称自己仅实现View</span> </h3>
<p>我看到有些人评论React没有遵循MVC分割Model和View，加重了代码的耦合程度。</p>
<p>比如Angular的Controller和Directive可以分别被认为是MVC（或MVVM）中的Model和View。
这就意味着你可以将一个component拆分开来，分别实现这两个部分，也让更小粒度的代码复用成为了可能。</p>
<p>但问题是明确地分割出Model和View可能在涉及复杂UI交互的领域并不是个最好的选择，
更多的场景可能需要我们根据实际情况和需求进行思考选择。
而Angular的这一套抽象方法很难适应现实的复杂情况。</p>
<p>并且你需要考虑如何去组织这些代码，并决定一个Controller或Directive到底要涉及多少功能，才能用的顺手。
Angular给我们提供了一套强大的工具，但你仍要去学习、实践怎么用好它们。</p>
<p>对于React来说，由于React并不分割Model和View，并且代码非常容易被修改、扩展，
所以你完全可以凭直觉来决定一个功能要如何实现，等待问题出现以后在进行修改。
因为只要你的代码不是真的太糟糕的话，这一过程真的并不痛苦。</p>
<p>事实上，如果MVC的重点在于Seperation of Concern，
那么React部件之间的作用范围分明本身就可以认为是这种思想的实践。
只要能解决问题，是不是MVC又有什么关系呢？</p>
<h3 id="3-">3. 学习曲线很重要</h3>
<p>并且在你希望你的同事接纳他们不熟悉的东西，或是需要给你的上司看到成果时，时显得更加重要。
虽然要用好React的话也需要学习不少东西，但这一过程会平滑的多得多。</p>
<h3 id="4-go-with-proven-and-solid-technologies-when-you-can-sidenote-what-powers-instagram-hundreds-of-instances-dozens-of-technologies-http-instagram-engineering-tumblr-com-post-13649370142-what-powers-instagram-hundreds-of-instances-">4. Go with proven and solid technologies when you can<label for="34" class="margin-toggle sidenote-number"></label><input type="checkbox" id="34" class="margin-toggle"/><span class="sidenote"><a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances">What Powers Instagram: Hundreds of Instances, Dozens of Technologies</a></span> </h3>
<p>除了Facebook和Instagram以外，看看<a href="https://github.com/facebook/react/wiki/Sites-Using-React">这里</a>，你会发现
Amazon, AirBnb, Uber,
支付宝，淘宝等公司、产品都在上面。不管这些大公司在他们的产品中到底使用了多少React
，至少这些公司对React都持肯定态度。Angular虽然也同样声名远播，但却不至于如此。</p>
<h2 id="-">结论</h2>
<p>我们需要框架来帮助我们的开发，其目的还是要解决现有的问题，加快开发效率，增强代码的复用，
并尽可能让我们可以把精力放在业务上。React虽然在开发效率上的优势不那么明显，但在其他问题
上发挥的作用是毋庸置疑的。</p>
<p>而React在拥有Virtual DOM以及不分离View、Model的大胆做法的同时，本身却非常注重工程实践。
特别是我们在从原生过渡到React的这一过程中更是能深刻地体会到这一点。React是适合用在生产环境上的。</p>
<h2 id="-react-">附：我们React一些实践结果</h2>
<p><strong>Virtual DOM的性能问题</strong></p>
<p>相比于原生js直接修改DOM，Virtual DOM需要多做一次“生成Virtual DOM“和一次”Virtual DOM“的比对，
所以我在开发过程中一直很关注React的性能问题（这可能同时也是不少反对前端框架开发的工程师的
论点之一）。碰巧我们应用的某个页面中，有可能会出现数百张
卡片同时出现在页面中的情况。在我按照这之前的方式把这个页面从原生改为React以后，我发现一旦
数百张卡片出现，每次改变应用的状态（state）都会有2秒左右的卡顿。</p>
<p>于是我按照<a href="https://facebook.github.io/react/docs/advanced-performance.html">React doc</a>的教程来
来尝试优化这个页面。这个教程上优化的要点实际上只有两点：</p>
<ol>
<li><p>使用<code>PureRenderMixin</code>，或是<code>componentShouldUpdate</code>阶段在不必要的情况下返回false。</p>
</li>
<li><p>在第一点的基础上，使用<a href="https://facebook.github.io/immutable-js/">Immutablejs</a>，来使得在数据结构比较复杂的情况下（Array, Object），
我们可以只比较reference的变化就判断component是否应该重新渲染。相当于减轻了比对过程的消耗，
同时也避免了一些本不必要的视图更新。</p>
</li>
</ol>
<p>这两个方法中我采用了前一个，我没有使用Immutablejs，但我用了React自带的
<a href="http://facebook.github.io/react/docs/update.html">Immutable Helper</a>来
达到相似的效果。</p>
<p>其结果是，问题并没有得到很好的改善。因为即便我避免了额外的Virtual DOM的生成、比对过程，但我们
的应用在状态发生改变时，仍会同时进行数百次对”是否要生成Virtual DOM并进行比对“的判断。</p>
<p>那么这个问题是否无法解决了呢？答案是否定的。我最后跳过了比对过程，直接利用<code>refs</code>和卡片中
事先定义好的方法来直接改变目标卡片的状态。这实际上就是退回到了原生实现。结果令人我满意。</p>
<p>所以我现在对React性能的看法是：<strong>绝大多数情况下没有问题，有问题的话也可以退回原生</strong>。</p>
<p><strong>代码量的变化</strong></p>
<p>代码越少，问题越少。在刚开始写Angular代码时，我印象深刻的一点是，你觉得自己的代码刚写
到一半，就突然发现你的功能已经基本完成了。我觉得。</p>
<p>那么对比原生，React的代码量会有什么变化呢？在我们的应用中，我正好有大量的机会来将原声代码
该写成React代码。根据我的观察，我们应用的React版本和原生的版本代码量（行数）差别不大。
有时React甚至会稍多一些。</p>
<p><strong>能否从原生（jquery）平滑迁移到React？</strong>
可以，我们正在做。你可能需要看看文档，结合实际情况多思考一下怎么做比较合适。</p>
<p><strong>在用React进行了一段时间的实践以后我最大的主观感受</strong>
我不再那么害怕我以前的代码和我同事的代码了。</p>
<blockquote>
<p>2015/8/30 TODO：补充示例和图片，每一点讲的更详细一些。</p>
</blockquote>
]]></description>
            <link>https://blog.oyyd.net/post/why_i_choose_react_rather_than_angular_in_our_company</link>
            <guid isPermaLink="false">46302d6994a8636ebb23f88ab4f1519b</guid>
            <pubDate>Thu, 27 Aug 2015 16:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>