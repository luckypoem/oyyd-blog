<h1 id="universal-isomorphic-javascript-react-">Universal(Isomorphic) JavaScript在React上的应用</h1>
<p>2015年11月26日</p>
<p>React中的renderToString方法允许我们在服务器上渲染React部件，这点不仅可以帮助我们解决一些会出现在单页应用(SPA)上的问题，它甚至还允许我们将React用作模板引擎（template engine）来使用。下文还将附带一个简单的benchmark来对比React与传统模板引擎之间性能。</p>
<h2 id="-universal-javascript-">什么是Universal Javascript？</h2>
<p>Universal Javascript又称Isomorphic JavaScript<label for="34" class="margin-toggle sidenote-number"></label><input type="checkbox" id="34" class="margin-toggle"/><span class="sidenote"><a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9">两个名称的来由</a></span> ，是指可以运行在客户端和服务器上的javascript代码。<label for="35" class="margin-toggle sidenote-number"></label><input type="checkbox" id="35" class="margin-toggle"/><span class="sidenote"><a href="http://isomorphic.net/">http://isomorphic.net</a></span> </p>
<p>实现Universal Javascript的原理并不复杂，我们只需要在代码中获取当前运行环境（浏览器还是服务器？），并根据环境作出不同响应即可。比如在<a href="https://www.meteor.com/">Meteor</a>中，你会看到这样的代码出现在同一个文件中：</p>
<pre><code class="lang-js">if (Meteor.isServer) {
  // This code only runs on the server
}

if (Meteor.isClient) {
  // This code only runs on the client
}
</code></pre>
<p>只要通过<code>Meteor.isServer</code>和<code>Meteor.isClient</code>，我们就能够控制代码在不同环境下的逻辑，从而使得这份代码可以同时在客户端和服务器上执行，并根据环境返回对应的结果。</p>
<h2 id="universal-javascript-react-">Universal JavaScript可以给React应用带来什么？</h2>
<p>那么对于React来讲，Universal Javascript又有什么用呢?我们知道，html标签加载了一部分就会显示一部分； 而React是通过javascript来渲染html内容的。这也就意味着在完成脚本的加载和运行之前，React应用中的html内容是不会出现在页面上的。</p>
<p>像是本站blog.oyyd.net原来是用React + React Router写的SPA(单页)应用，页面内容是这样的：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;oyyd blog - 这是亚东的博客（偏技术），你可以在上面看到我的一些想法和实践，欢迎来访。&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;meta name=&quot;description=&quot; content=&quot;内容偏前端，但不局限于前端，没准你会感兴趣。&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以看到代码中基本没有与内容相关的html标签，这就导致SPA一直存在的一些<strong>问题</strong>：</p>
<ol>
<li><p>用户在脚本加载运行之前是不会看到React部分的内容，从体验上来讲好像等待了更多的时间（特别是在网速差的时候）。</p>
</li>
<li><p>如果javascrript加载失败或是运行时产生错误的话（或是浏览器直接禁用了javascript的话），用户看不到任何内容。</p>
</li>
<li><p>搜索引擎无法有效地爬取页面内容<label for="36" class="margin-toggle sidenote-number"></label><input type="checkbox" id="36" class="margin-toggle"/><span class="sidenote">对于google而言，有一些<a href="https://developers.google.com/webmasters/ajax-crawling/docs/getting-started">解决办法</a>来引导爬虫去另一个事先准备好页面内容的地方</span> ，难以进行SEO。</p>
</li>
</ol>
<p>对于这些问题，我们可以利用Universal JavaScript，也即React中的<code>renderToString</code>方法，在服务器上就渲染出React应用中的部分内容返回给浏览器，从而解决这些问题。</p>
<h2 id="-">实现</h2>
<p>现在的blog.oyyd.net就充分利用了React中的<code>renderToString</code>。你可以在浏览器中查看源码来查看这个网站现在的状况。接下来还是让我们通过一个更加简洁的例子来了解这一流程：</p>
<blockquote>
<p>注意：下面的代码并不完备，由于构建过程相对繁杂多样，所以这些代码更多是为了让我们能更好地关注这一流程中的重点步骤。</p>
</blockquote>
<p>假设我们要实现一个简单的计数器，这个计数器的初始值会在服务器端就设置好。</p>
<p>整个流程大致如下：</p>
<ol>
<li><p>请求到来，服务器初始化我们的React计数器，并将其渲染成字符串。</p>
</li>
<li><p>把React生成的字符串和计数器的初始值放到模板中，合并成完整的HTML内容返回给浏览器。</p>
</li>
<li><p>在浏览器上，利用计数器的初始值初始化React应用。</p>
</li>
</ol>
<p>其中我们的React计数器代码如下：</p>
<pre><code class="lang-js">// Counter.js
import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props){
    super(props);
    this.state = {
      count: props.initialCount,
    };
  }
  countPlusOne(){
    this.setState({
      count: this.state.count + 1,
    });
  }
  render(){
    return (
      &lt;div&gt;
        &lt;label&gt;数值: {this.state.count}&lt;/label&gt;
        &lt;button onClick={this.countPlusOne.bind(this)}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Counter;
</code></pre>
<p>当请求来临时，express根据参数设置初始状态生成一个Counter的ReactElement,并将其渲染成字符串：</p>
<pre><code class="lang-js">// server.js
import fs from &#39;fs&#39;;
import express from &#39;express&#39;;
import React from &#39;react&#39;;
import {renderToString} from &#39;react-dom/server&#39;;

import Counter from &#39;./components/Counter&#39;;

const app = express();
app.get(&#39;/:initialCount&#39;, (req, res) =&gt; {
  const {initialCount} = req.params;

  // 生成Counter实例的字符串
  const counterString = renderToString(
    &lt;Counter initialCount={initialCount}/&gt;
  );

  // 注意下面不仅将Counter的字符串放入了html内容中，并且
  // 还将参数保存在了全局浏览器上的全局变量`__INITIAL_COUNT__`
  req.send(
    \`&lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${counterString}&lt;/div&gt;
        &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          window.\__INITIAL_COUNT\__ = ${initialCount};
        &lt;/script&gt;
        &lt;script src=&quot;/bootstrap.js&quot;&gt;&lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;\`
  );
});

app.listen(8080);
</code></pre>
<p>当浏览器上的请求从服务器上返回时，bootstrap.js脚本被加载运行，在浏览器上初始化完整的React应用：</p>
<pre><code class="lang-js">// bootstrap.js
React.render(
  &lt;Counter initialCount={window.\__INITIAL_COUNT\__}/&gt;,
  document.getElementById(&#39;main&#39;)
);
</code></pre>
<p>到这里，我们的计数器应用就顺利地加载在了浏览器上，并且这一次，我们的页面一开始不会像SPA应用那样空空如也。</p>
<p>这一过程就像是我们的React应用的初始化过程被分成了两次进行。先是在服务器上，我们初始化了React应用中的HTML的内容，并发送到前端；然后浏览器接过了这些内容，继续进行DOM事件绑定等工作。而值得注意的是，为了能在前端以正确的初始状态启动应用，我们需要把我们应用的状态（上面例子中的<code>window.\__INITIAL_COUNT\__</code>）也一并传过去，用于初始化。</p>
<h2 id="-react-">事实上，我们在用React替代服务器端的模板引擎</h2>
<p>如果你回想一下这一过程，你可能会注意到在这一流程中，React承担起了服务器上本应由模板引擎处理的(template engine)大部分工作<label for="37" class="margin-toggle sidenote-number"></label><input type="checkbox" id="37" class="margin-toggle"/><span class="sidenote"><del>现在的React是无法生成<code>html</code>, <code>script</code>等标签的</del>很惭愧，事实上是可以的。</span> 。</p>
<p>如果你写过服务器端模板，同时也很熟悉React，那你可能会和我有同样的感受：React中的模板（或者说是jsx）用起来甚至比专业的模板引擎更加顺手。因为使用模板引擎意味着你在用一门模板语言和javascript交互；而React本身就是javascript，jsx本质也是javascript，所以React中的“模板”用起来要自然得多。</p>
<p>如果你只需要静态页面的话，你完全可以写一些没有state的React部件来承担服务器上模板引擎的大部分工作。事实上现在已经有<a href="https://github.com/reactjs/express-react-views">express-react-views</a>这样的库来实现这一目的<label for="38" class="margin-toggle sidenote-number"></label><input type="checkbox" id="38" class="margin-toggle"/><span class="sidenote">其作者也是React的维护者<a href="https://github.com/zpao">@zpao</a></span> 。</p>
<p>那么让一门前端框架作为模板引擎是不是多余之举呢？</p>
<p>事实可能完全相反。因为浏览器上js所使用的模板和服务器上渲染的模板原本就应该是同一份模板，它们同属于我们浏览器上的应用。只不过由于种种原因，我们一直不得不将其拆分成两部分。那么现在如果服务器的这份模板由本身就主要用于浏览器上的React来生成的话，我觉得是再合理不过的了。</p>
<p><img src="/static/posts/react-server-render/react-as-template-engine.png" alt="React as Template Engine"></p>
<p><del>当然因为React无法生成所有常用的标签，所以你可能还是需要模板引擎来帮你处理React应用之外的工作。</del>一般我们用在浏览器上的React应用不会用到诸如：html，script，body这样的标签，但我们可以在服务器渲染时使用他们来生成完整的内容。</p>
<p>并且这样做，我们可以充分利用同一份代码，技术栈也会变得更加简单。想象一下，没有html、template、ejs、jade等文件，你的js文件就是你的模板文件，你可以直接利用js上的模块等特性，这能够省多少事！</p>
<p>但是如果你把之前用于浏览器上的React部件直接拿来服务器渲染的话，你可能没办法如愿。举个例子：在浏览器上你很可能在会直接使用全局变量window，但在node上这会抛出错误。你需要在写你的应用的时候就考虑清楚一个部件在服务器上渲染时的情况。</p>
<p>而你的React部件拥有state的话，你是没办法直接控制他们的状态的。但如果你使用<a href="https://github.com/rackt/redux">Redux</a>来将部件中的state移动到外部的话，你就可以通过Redux来从外部自由控制你部件的状态，也就可以控制服务器端渲染的内容了。</p>
<h2 id="-benchmark">一个简单的benchmark</h2>
<p>React不是纯粹的模板引擎，那么与node上其他的模板引擎相比，它的server render的性能会不会差很多呢？这里我们将前面的计数器代码做一下改动，通过一个小范围的、非常简单的benchmark来对比React和ejs之间性能的量级：</p>
<blockquote>
<p>这里还是要再次强调：这个benchmark的目的只是在于帮助我们了解他们之间大概的性能，实际应用时的状况很可能不是这样的。</p>
</blockquote>
<p>设备：Windows 8.1 Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz 2.59GHz  8.00GB</p>
<p>版本：React 14.0.2，ejs 2.3.4</p>
<p>ejs使用的模板文件：</p>
<pre><code class="lang-html">&lt;div&gt;
  &lt;label&gt;数值:&lt;%=count%&gt;&lt;/label&gt;
  &lt;button&gt;+1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>React Counter(es6中类的形式)<label for="39" class="margin-toggle sidenote-number"></label><input type="checkbox" id="39" class="margin-toggle"/><span class="sidenote">下面的代码都使用了babel进行转换，可能对结果会产生一些影响</span> ：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

class Counter extends React.Component{
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<p>React Counter(传统方式)：</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

const Counter = React.createClass({
  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;数值:{this.props.count}&lt;/label&gt;
        &lt;button&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    );
  },
});

export default Counter;
</code></pre>
<p>测试时的渲染语句：</p>
<pre><code>// React
renderToString(&lt;Counter count={10}/&gt;);

// ejs
ejs.render(template, {
  count: 10,
});
</code></pre><p>设置node环境为<code>production</code>，避免React做一些用于开发环境的工作，并开始渲染：</p>
<pre><code>NODE_ENV=production node lib/index.js
</code></pre><p>结果如下：</p>
<p>数值单位是ope/sec（每秒渲染数）越高越好</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>第1次</th>
<th>第2次</th>
<th>第3次</th>
<th>第4次</th>
<th>第5次</th>
</tr>
</thead>
<tbody>
<tr>
<td>React ES6 class</td>
<td>7981</td>
<td>9043</td>
<td>11718</td>
<td>8165</td>
<td>8034</td>
</tr>
<tr>
<td>React classic</td>
<td>7172</td>
<td>6904</td>
<td>7421</td>
<td>7592</td>
<td>8030</td>
</tr>
<tr>
<td>ejs</td>
<td>17905</td>
<td>17743</td>
<td>16763</td>
<td>19261</td>
<td>17437</td>
</tr>
</tbody>
</table>
<p>然后你可以在通过下面这个链接再对比一下ejs和node上其他一些模板引擎的性能，来了进行更详细的对比：<a href="http://paularmstrong.github.io/node-templates/benchmarks.html">Node Template Engine Benchmarks</a><label for="40" class="margin-toggle sidenote-number"></label><input type="checkbox" id="40" class="margin-toggle"/><span class="sidenote">如果这个结果对于其他情况也是有效的话，那或许我们可以认为React的性能超过了jade。当然我说的是“或许”。</span> 。</p>
<p>如果这个结果对于其他情况也是有效的话，那我个人认为React server render的性能已经够用了，甚至该说是足够优秀了。况且React远不止是模板引擎。</p>
<h2 id="-">结论</h2>
<p>相对于其他语言来说，Universal JavaScript恐怕是Node在web上所具有的最独特的特性，也是最值得去挖掘的。我们这里讨论了一些React在服务器上的使用及其潜力，也一笔带过了实际应用中存在的一些问题。更深入的内容就留待以后吧。</p>
<h2 id="-">相关链接</h2>
<p>StrongLoop的教程: <a href="https://strongloop.com/strongblog/node-js-react-isomorphic-javascript-why-it-matters/">How to Implement Node + React Isomorphic JavaScript &amp; Why it Matters</a></p>
<p><a href="https://github.com/erikras/react-redux-universal-hot-example">React Redux Universal Hot Example</a></p>
<p><a href="https://github.com/aickin/react-dom-stream">react-dom-stream</a></p>
