<h1 id="-javascript-marked">探究JavaScript上的编译器 —— marked</h1>
<p><strong>前言：</strong></p>
<p>如果你也用google去搜过编译相关的话题的话，会发现很难找到适合入门的内容。但与之相对的是，很多的库和特性的实现都离不开编译这一流程，我们去看一些开源的JavaScript代码时也经常会看到Lexer，Parser，Compiler，AST等东西。如果没有相关知识，那看这些代码时经常会一头雾水。</p>
<p>实际上在学习这部分内容时，可能阅读书籍(<a href="http://www.amazon.com/dp/0321486811/?tag=stackoverfl08-20">编译原理</a>)是最合适的。因为编译的原理基本相近，也没有随时间推移而发生大的改变，经典的书籍依旧非常适用，但这里将尝试通过一些开源项目的代码来学习编译。虽然这种学习方式可能不够详尽，容易遗漏内容，但它也更有利于我们学习到开发实践中常用的编译（它们的代码结构通常会更加简单），以及了解不同环境下的编译过程的设计。</p>
<p>但这个话题本身涉及的范围较广，内容较深，所以对这些内容的学习将通三个项目的源码进行，它们分别是：<a href="https://github.com/chjj/marked">marked</a> —— 它将markdown文本转换成可供浏览器使用的HTML标签, <a href="https://github.com/mozilla/nunjucks/">nunjucks</a> —— 模板引擎和<a href="http://zaach.github.io/jison/">Jison</a> —— 一个通用的parser生成器，三部分进行。</p>
<p>那这次让我们从marked开始。</p>
<h2 id="-">基础理论：一个编译器的结构</h2>
<p>首先还是让我们通过来粗略了解一下编译器的通用结构（摘自编译原理）：</p>
<ol>
<li><p>Lexical Analysis/Scanning（词法分析），在marked中由Lexer实现。</p>
</li>
<li><p>Syntax Analysis/Parsing（语法分析），在marked中由Parser实现。</p>
</li>
<li><p>Semantic Analysis（语义分析），代码优化，在marked中没有实现。</p>
</li>
<li><p>代码生成，在marked中由Parser和Renderer实现。</p>
</li>
</ol>
<h2 id="marked-">marked中的代码结构</h2>
<p>marked的目的是根据输入的markdown文本来输出可供浏览器解析的HTML内容，藉由：</p>
<pre><code class="lang-markdown"># 探究JavaScript上的编译器 —— marked

编译这个话题在JavaScript上很少出现...
</code></pre>
<p>生成类似这样的代码：</p>
<pre><code class="lang-html">&lt;h1&gt;探究JavaScript上的编译器 —— marked&lt;/h1&gt;
&lt;p&gt;
  编译这个话题在JavaScript上很少出现...
&lt;/p&gt;
</code></pre>
<p>编译目标的不同会直接使得我们代码结构大相径庭。所以对任何编译相关的代码，时刻明确我们的设计的目的可以很好地帮助我们理解代码。</p>
<p>marked由四部分组成，分别是: Lexer、InlineLexer、Parser、Renderer。</p>
<p><img src="/static/posts/javascript-compiler/marked_composition.png" alt="marked-composition"></p>
<p>其中Lexer会处理最原始的文本，它将文本处理、抽象，提供tokens供Parser使用；Renderer提供一组api供Parser和InlineLexer调用，以生成HTML；而Parser将对Lexer提供的tokens进行进一步处理，并据此调用Renderer中的api生成最终的HTML字符串。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer用来将源码转换成tokens供Parser使用，其表现如下：</p>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# title&#39;);

// tokens:  
// [ { type: &#39;heading&#39;, depth: 1, text: &#39;title&#39; } ]
</code></pre>
<p>Lexer生成的tokens事实上只是对源码的抽象和描述。通常tokens都会有一个属性来描述其“类型”（上面生成的tokens中的“type”属性），并有可能有一个或多个“值”属性来描述具体信息（上面tokens中的“title”和“title”属性）。</p>
<h3 id="inlinelexer">InlineLexer</h3>
<p>marked中还有InlineLexer，从名称上看我们可以猜测它的整体作用和Lexer相近。但InlineLexer是有两点不同：一是InlineLexer只用于处理诸如：<code>__strong__</code>、<code>~~line-through~~</code>这样的内联文本；二是InlineLexer不返回tokens给Parser使用，它会直接利用Renderer将源码转换成HTML内容。</p>
<pre><code class="lang-js">const output = marked.InlineLexer.output(&#39;__strong content__&#39;, {}, {});
// output: &#39;&lt;strong&gt;strong content&lt;/strong&gt;&#39;
</code></pre>
<p>所以Parser在处理内联文本时，是直接使用InlineLexer生成结果，而不是像Lexer一样依据tokens用Renderers生成HTML。</p>
<h3 id="renderer">Renderer</h3>
<p>在Parser之前，我们先来看看Renderer的表现。我们可以直接使用Renderer生成HTML:</p>
<pre><code class="lang-js">const options = {
  headerPrefix: &#39;header-id&#39;,
};
const renderer = new marked.Renderer(options);
const output = renderer.heading(&#39;hello world&#39;, 2, &#39;&#39;);

// output: &#39;&lt;h2 id=&quot;header-id&quot;&gt;hello world&lt;/h2&gt;&#39;
</code></pre>
<p>我们可以看到在marked中，Renderer上的方法生成的内容就是我们所期望的HTML内容了。</p>
<h3 id="parser">Parser</h3>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# hello world&#39;);
const output = marked.Parser.parse(tokens);
// output: &lt;h1 id=&quot;hello-world&quot;&gt;hello world&lt;/h1&gt;
</code></pre>
<p>因为markdown的语法规则不像编程语言一样复杂，所以marked中的Parser相对简单，基本上就是按顺序将tokens转换成转换成HTML内容。</p>
<h2 id="-marked">实践：扩展marked</h2>
<p>为了验证对marked的理解是否正确，我试着fork并修改了marked的代码（<a href="https://github.com/oyyd/marked-chartjs-binding">github地址</a>），绑定了chartjs，令我们可以在markdown中调用渲染图表。</p>
<p>你可以在这篇关于<a href="https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages">Universal React</a>的文章底部的benchmark部分看到柱状图。</p>
<p>在修改中，我加入了如下的语法：</p>
<pre><code class="lang-md">graph.chartName
// JSON data here which will be used by
endgraph
</code></pre>
<p>其中chartName将被用作chartjs的图表名，如：graph.Bar将使用chartjs中的Bar表。其对应的token形如：</p>
<pre><code class="lang-js">{
  type: &#39;graph&#39;,
  name: &#39;chartName&#39;, // chartn
  data: &#39;...&#39; // expecting JSON string containing `data` and `options` as the parameters of Chart
}
</code></pre>
<p>而在<code>graph.chartName</code>和<code>endgraph</code>之间的内容将作为图表的参数。修改过后的marked最终渲染出如下的内容：</p>
<pre><code class="lang-html">&lt;script type=&quot;text/chartdata&quot; data-chartname=&quot;chartName&quot;
  style=&quot;display:none;&quot;&gt;
// ...json string here
&lt;/script&gt;
</code></pre>
<p>事实上我们只是渲染了一个script标签来保留图表信息，修改过后的marked并不能让我们在浏览器上直接看到图表。这是由于浏览器的限制，涉及到script的内容在处理时会遇到各种问题，所以在我的处理里，我使用<code>renderCharts()</code>方法去文档中搜索这样的标签，从而真正地渲染图表。</p>
<h2 id="-">相关链接</h2>
<p><a href="http://programmers.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler">How to write a very basic compiler</a></p>
<p><a href="http://stackoverflow.com/questions/2842809/lexers-vs-parsers">lexers vs parsers</a></p>
