#我更熟悉Angular，但为什么我还是选择了React来做前端？

__前言：__

很早以前，我[曾经写过自己对React的看法]()，但那时候自己基本是囫囵吞枣，
只是去看了React最明显的那些特性，完全没有去尝试深入理解其中的设计思想。
其结果便是我完全没有理解到React的优点。直到最近，我们公司和其他大多数初创
公司一样，需要真正地正视前端开发中的问题，并开始进行重构。这时我不得不
从我熟悉的Angular和另一个不少大牛极力推荐的框架——React中作出选择。
于是在仔细思考我们开发中的问题，并结合了他人的看法之后，我选择了React。

##只用原生（或jQuery）开发时遇到的问题

__缺少有效抽象__

当一个项目刚刚开始时，用原生js进行开发一般不会遇到特别严重的问题。但当
项目进行了一段时间以后，。我们的leader曾经说过

我们可以看看我们去修改一个功能或修复一个bug时的一般性做法：

1. 寻找DOM（在浏览器审查元素）

2. 看一下这个DOM上比较像钩子的属性（`id`, `class`, `role`, `data-xxx`）

3. 搜索代码中用了这个钩子的地方（基本上通过文本搜索找`$()`）

4. 若命中则进入下一个地方，否则从1, 2, 3中的某一步重新开始，直到命中。

而即便你找到了要修改代码，如果你没有遍历上述流程中的每一种情况，你就很难保证你没有
遗漏其他情况。特别是在修改他人的代码时，你很难保证自己做出的修改是完整的、没有副作用的。
而在代码量增大以及

产生这一问题的原因，因为抽象混乱，或者说，不仔细考虑代码怎么写的话，就根本没有抽象。
这就导致了我们在看代码时，虽然很明确每一个小操作的作用，但自顶至底来看，
却很难明确每一个操作的目的。$sidenote(意大利面代码)

本身javascript的特点和历史原因就导致了不使用一套框架代码的 这也是为什么我觉得在生产
环境中使用一套框架的必要性。过程式的，缺乏有效的抽象 + 动态类型，闭包（作用域链），
全局作用域等 = 难理解，难预测追踪，难扩展。

__代码复用__

除了缺少抽象导致的代码难以理解、修改以外，另一个不良后果便是很难确定代码的作用范围。

举个现实中很常见的例子：PM往往会认为如果你网站上已经有了东西，那么在其他地方
使用这个东西（或实现类似的东西）并不会消耗程序员的时间，至少不会消耗太多。

然而实际上我在面对这一问题时，我多半会想：“当时我没觉得它会被复用，我可能要先花点
时间把它抽出来”。而“抽出来”便是要确定这个功能的作用范围，或者说我需要确定这部分代码
的依赖，和依赖这部分代码的代码，以保证我把这部分代码拿出来以后，这部分代码和其他代码
都不会因为未声明的变量和函数抛出错误。

__DOM操作__

看一眼我们的jQuery代码（或原生），不难发现我们绝大多数时候都是在“query DOM”（$(),或是getElement...）。
因为在改变DOM之前，我们首先要找出目标DOM。其本质问题在于DOM树的状态和javascript
（中的数据）的状态是分离的，即我们需要用“query”的方式去人工维护DOM树和javascript
的一致性。维护这两者一致的工作本身是不可必变的，问题是在代码量变大、代码变复杂的情况下，
这一工作的代价可能要比我们想象的要复杂的多$sidenote。

##对于这两个问题，React做了什么？

###树状结构$sidenote()
React要求每一个ReactClass的渲染方法中，都有且只有一个最外层的Virtual DOM，但它内部
（children属性）可以包含多个Virtual DOM。所以用React写的应用的结构是树状的。
React应用的树状结构使得任何一个ReactClass都只和它的外层ReactClass以及
子ReactClass进行直接交互，也即我们很容易弄清楚我们某一部分代码的作用范围。这就使得
我们在修改React的代码时会格外轻松。实际上这一点对于设计到UI的代码来说是十分重要的，
因为我个人觉得通常在产品需求变化时，UI的变化经常会需要你不断地考虑是否要对代码做
抽象，分离出一部分公用的内容。而React会让你的每一部分代码都为复用做好准备。

pic

tradeoff
###容易确定的数据流
大多数情况下，我们都可以通过改变应用中的数据来改变React应用的状态。很多时候我们在追踪
应用的状态时，实际上都是在追踪数据的变化。所以掌握数据的状态在维护及扩展时是非常重要的。
得益于前面所述的树状结构，React应用的数据流向十分清晰明。

除了这点，React应用中的每一部分都使用props和states两个属性来储存状态。
其中props属性是外部传入的，在ReactElement部不（应该）发生改变；
而state属性产生于ReactElement的内部，可传递到子ReactElement中作为props。
这两个属性很好地将控制components状态的数据进行了分类，让我们更容易在局部代码中的数据
进行朔源。

###直接生成Virtual DOM来取代DOM操作
我们写的React代码并不直接操作DOM，而是根据当前的数据组织出一个Virtual DOM，然后由
Virtual DOM完成对DOM树的调节。

由于新生成的Virtual DOM会和上一次的Virtual DOM进行比对，
然后根据Virtual DOM之间的差别对DOM树进行最小的、必要的调节，所以这一做法在大多数
情况下都能够保证性能$sidenote。

而组织Virtual DOM来操作DOM的更大好处在于：你不需要
考虑将DOM树从当前的状态A变成目标状态B所需要进行的每一个DOM操作，而只要根据当前数据的
状态去组织一个目标状态B的Virtual DOM即可，所以这种做法节省了我们的很多工作。

另外值得一提的是，当我把组织Virtual DOM的过程当成是一种模板引擎，并于其他模板做对比时
，我发现Virtual DOM + jsx异常灵活。

What Benifits?
###生命周期
并让我们
更容易追踪代码

###React的其他一些话题

性能  退回原生。

##关于Angular

MVC

学习曲线

##结论
