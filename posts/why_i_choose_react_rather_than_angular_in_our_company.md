#为什么我们选择了React来做前端

__前言：__

很早以前，我[曾经写过自己对React的看法]()，但那时候自己基本是囫囵吞枣，
只是去看了React最明显的那些特性，完全没有去尝试深入理解其中的设计思想。
其结果便是我完全没有理解到React的优点。直到最近，我们公司和其他大多数初创
公司一样，需要真正地正视前端开发中的问题，并开始进行重构。这时我不得不
从我熟悉的Angular和另一个不少大牛极力推荐的框架——React中作出选择。
于是在仔细思考我们开发中的问题，并结合了他人的看法之后，我选择了React。

这里特别推荐[jlongster的这篇关于React的文章]()。他通过重新"造轮子"的过程直击了问题的重点。

当然首先让我们从稍远一点的话题开始。

##只用原生（或jQuery）开发时遇到的问题

__缺少有效抽象__

当一个项目刚刚开始时，用原生js进行开发一般不会遇到特别严重的问题。但当
项目进行了一段时间以后。我们的leader曾经说过的（近似）：我觉得看java（服务器上的）
和android的代码都很简单，但是javascript的代码太难看了。

我们可以看看我们去修改一个功能或修复一个bug时的一般性做法：

1. 寻找DOM（在浏览器审查元素）

2. 看一下这个DOM上比较像钩子的属性（`id`, `class`, `role`, `data-xxx`）

3. 搜索代码中用了这个钩子的地方（基本上通过文本搜索找`$()`）

4. 若命中则进入下一个地方，否则从1, 2, 3中的某一步重新开始，直到命中。

而即便你找到了要修改代码，如果你没有遍历上述流程中的每一种情况，你就很难保证你没有
遗漏其他情况。特别是在修改他人的代码时，你很难保证自己做出的修改是完整的、没有副作用的。

产生这一问题的原因，因为抽象混乱，或者说，不仔细考虑代码怎么写的话，就根本没有抽象。
这就导致了我们在看代码时，虽然很明确每一个小操作的作用，但自顶至底来看，
却很难明确每一个操作的目的。

本身javascript的特点和历史原因就导致了不使用一套框架代码的 这也是为什么我觉得在生产
环境中使用一套框架的必要性。过程式的，缺乏有效的抽象 + 动态类型，闭包（作用域链），
全局作用域等 = 难理解，难预测追踪，难扩展。

__代码复用__

除了缺少抽象导致的代码难以理解、修改以外，另一个不良后果便是很难确定代码的作用范围。

举个现实中很常见的例子：PM往往会认为如果你网站上已经有了东西，那么在其他地方
使用这个东西（或实现类似的东西）并不会消耗程序员的时间，至少不会消耗太多。

然而实际上我在面对这一问题时，我多半会想：“当时我没觉得它会被复用，我可能要先花点
时间把它抽出来”。而“抽出来”便是要确定这个功能的作用范围，或者说我需要确定这部分代码
的依赖，和依赖这部分代码的代码，以保证我把这部分代码拿出来以后，这部分代码和其他代码
都不会因为未声明的变量和函数抛出错误。

__DOM操作__

看一眼我们的jQuery代码（或原生），不难发现我们绝大多数时候都是在“query DOM”（$(),或是getElement...）。
因为在改变DOM之前，我们首先要找出目标DOM。其本质问题在于DOM树的状态和javascript
（中的数据）的状态是分离的，即我们需要用“query”的方式去人工维护DOM树和javascript
的一致性。维护这两者一致的工作本身是不可避免的，问题是在代码量变大、代码变复杂的情况下，
这一工作的代价可能要比我们想象的要复杂的多$sidenote([Localytics的一篇blog中提到过这一点](http://www.csdn.net/article/2013-04-12/2814864-Localytics-AngularJS-Backbone))。

##对于这两个问题，React做了什么？

###树状结构
React要求每一个ReactClass的渲染方法中，都有且只有一个最外层的Virtual DOM，但它内部
（children属性）可以包含多个Virtual DOM。所以用React写的应用的结构是树状的$sidenote()。
React应用的树状结构使得任何一个ReactClass都只和它的外层ReactClass以及
子ReactClass进行直接交互，也即我们很容易弄清楚我们某一部分代码的作用范围。这就使得
我们在修改React的代码时会格外轻松。实际上这一点对于涉及到UI的代码来说是十分重要的，
因为我个人觉得通常在产品需求变化时，UI的变化经常会需要你不断地考虑是否要对代码做
抽象，分离出一部分公用的内容。而React会让你的每一部分代码都为复用做好准备。

###容易确定的数据流
大多数情况下，我们都可以通过改变应用中的数据来改变React应用的状态。很多时候我们在追踪
应用的状态时，实际上都是在追踪数据的变化。所以掌握数据的状态在维护及扩展时是非常重要的。
得益于前面所述的树状结构，React应用的数据流向十分清晰明。

除了这点，React应用中的每一部分都使用props和states两个属性来储存状态。
其中props属性是外部传入的，在ReactElement部不（应该）发生改变；
而state属性产生于ReactElement的内部，可传递到子ReactElement中作为props。
这两个属性很好地将控制components状态的数据进行了分类，让我们更容易在局部代码中的数据
进行朔源。

###直接生成Virtual DOM来取代DOM操作
我们写的React代码并不直接操作DOM，而是根据当前的数据组织出一个Virtual DOM，然后由
Virtual DOM完成对DOM树的调节。

由于新生成的Virtual DOM会和上一次的Virtual DOM进行比对，
然后根据Virtual DOM之间的差别对DOM树进行最小的、必要的调节，所以这一做法在大多数
情况下都能够保证性能$sidenote。

而组织Virtual DOM来操作DOM的更大好处在于：你不需要
考虑将DOM树从当前的状态A变成目标状态B所需要进行的每一个DOM操作，而只要根据当前数据的
状态去组织一个目标状态B的Virtual DOM即可，所以这种做法节省了我们的很多工作。

另外值得一提的是，当我把组织Virtual DOM的过程当成是一种模板引擎，并于其他模板做对比时
，我发现Virtual DOM + jsx异常灵活。

##没有选择Angular的原因
你可能容易在Angular和Ember之间做比较，但却很难将React与前面两者做比较。因为他们之间过于不同，以至于我把这篇文章的初衷都稍作了修改。所以这里更多从实践的角度谈谈我的看法，可能充满了个人偏见。

1. 适合生产环境的框架应该尽可能减少工程师的思考

Angular很强大，但要用好它，需要要保证工程师同样强大。举例来说，Angular通过Controller和Directive可以分别被认为是MVC（或MVVM）中的Model和View。这就意味着你可以将一个component拆分开来，分别实现这两个部分，也让更小粒度的代码复用成为了可能。然而问题有两点：一是你需要考虑如何去组织这些代码，并决定；二是在客户端UI上要分开复用这两者的情况可能不多，或是比较困难。在于你需要去手动组织$sidenote()

2. 学习曲线很重要。

3. 

4. Use Proofed Technology

##附：我们React一些实践结果

__Virtual DOM的性能问题__

相比于原生js直接修改DOM，Virtual DOM需要多做一次“生成Virtual DOM“和一次”Virtual DOM“的比对，
所以我在开发过程中一直很关注React的性能问题（这可能同时也是不少反对前端框架开发的工程师的
论点之一）。碰巧我们应用的某个页面中，有可能会出现数百张
卡片同时出现在页面中的情况。在我按照这之前的方式把这个页面从原生改为React以后，我发现一旦
数百张卡片出现，每次改变应用的状态（state）都会有2秒左右的卡顿。

于是我按照[React doc](https://facebook.github.io/react/docs/advanced-performance.html)的教程来
来尝试优化这个页面。这个教程上优化的要点实际上只有两点：

1. 使用[PureRenderMixin]()，或是`componentShouldUpdate`阶段在不必要的情况下返回false。

2. 在第一点的基础上，使用[Immutablejs]()，来使得在数据结构比较复杂的情况下（Array, Object），
我们可以只比较reference的变化就判断component是否应该重新渲染。相当于减轻了比对过程的消耗，
同时也避免了一些本不必要的试图更新。

这两个方法中我采用了前一个，我没有使用Immutablejs，但我用了React自带的[Immutable Helper]()来
达到相似的效果。

其结果是，问题并没有得到很好的改善。因为即便我避免了额外的Virtual DOM的生成、比对过程，但我们
的应用在状态发生改变时，仍会同时进行数百次对”是否要生成Virtual DOM并进行比对“的判断。

那么这个问题是否无法解决了呢？答案是否定的。我最后跳过了比对过程，直接利用`refs`和卡片中
事先定义好的方法来直接改变目标卡片的状态。这实际上就是退回到了原生实现。结果令人我满意。

所以我现在对React性能的看法是：绝大多数情况下没有问题，有问题的话也可以退回原生。

__代码量的变化__

代码越少，问题越少。在刚开始写Angular代码时，我印象深刻的一点是，你觉得自己的代码刚写
到一半，就突然发现你的功能已经基本完成了。我觉得。

那么对比原生，React的代码量会有什么变化呢？在我们的应用中，我正好有大量的机会来将原声代码
该写成React代码。根据我的观察，我们应用的React版本和原生的版本代码量（行数）差别不大。
有时React甚至会稍多一些。

##结论
